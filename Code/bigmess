importsocketimportosimportsysimportstructimporttimeimportselect#Derivedfromping.cdistributedinLinux'snetkit.Thatcodeis#copyright(c)1989byTheRegentsoftheUniversityofCalifornia.#ThatcodeisinturnderivedfromcodewrittenbyMikeMuussofthe#USArmyBallisticResearchLaboratoryinDecember,1983and#placedinthepublicdomain.Theyhavemythanks.#Bugsarenaturallymine.I'dbegladtohearaboutthem.Thereare#certainlyword-sizedependenceieshere.#Copyright(c)MatthewDixonCowles,<http://www.visi.com/~mdc/>.#DistributableunderthetermsoftheGNUGeneralPublicLicense#version2.Providedwithnowarrantiesofanysort.#NotethatICMPmessagescanonlybesentfromprocessesrunning#asroot.#Revisionhistory:##November22,1997#Initialhack.Doesn'tdomuch,butratherthantrytoguess#whatfeaturesI(orothers)willwantinthefuture,I'veonly#putinwhatIneednow.##December16,1997#Forsomereason,thechecksumbytesareinthewrongorderwhen#thisisrununderSolaris2.XforSPARCbutitworksrightunder#Linuxx86.SinceIdon'tknowjustwhat'swrong,I'llswapthe#bytesalwaysandthendoanhtons().##December4,2000#Changedthestruct.pack()callstopackthechecksumandIDas#unsigned.MythankstoJeromePoinchevalforthefix.##From/usr/include/linux/icmp.h;yourmilagemayvary.ICMP_ECHO_REQUEST=8#SeemstobethesameonSolaris.#I'mnottooconfidentthatthisisrightbuttestingseems#tosuggestthatitgivesthesameanswersasin_cksuminping.cdefchecksum(str):csum=0countTo=(len(str)/2)*2count=0whilecount<countTo:thisVal=ord(str[count+1])*256+ord(str[count])csum=csum+thisValcsum=csum&0xffffffff#Necessary?count=count+2ifcountTo<len(str):csum=csum+ord(str[len(str)-1])csum=csum&0xffffffff#Necessary?csum=(csum>16)+(csum&0xffff)csum=csum+(csum>16)answer=~csumanswer=answer&0xffff#Swapbytes.BuggermeifIknowwhy.answer=answer>8|(answer<<8&0xff00)returnanswerdefreceiveOnePing(mySocket,ID,timeout):timeLeft=timeoutwhileTrue:startedSelect=time.time()whatReady=select.select([mySocket],[],[],timeLeft)howLongInSelect=(time.time()-startedSelect)ifwhatReady[0]==[]:#Timeoutreturn-1timeReceived=time.time()recPacket,addr=mySocket.recvfrom(1024)icmpHeader=recPacket[20:28]typ,code,checksum,packetID,sequence=struct.unpack("bbHHh",icmpHeader)ifpacketID==ID:bytesInDouble=struct.calcsize("d")timeSent=struct.unpack("d",recPacket[28:28+bytesInDouble])[0]returntimeReceived-timeSenttimeLeft=timeLeft-howLongInSelectiftimeLeft<=0:return-1defsendOnePing(mySocket,destAddr,ID):#Headeristype(8),code(8),checksum(16),id(16),sequence(16)myChecksum=0#Makeadummyhederwitha0checksum.header=struct.pack("bbHHh",ICMP_ECHO_REQUEST,0,myChecksum,ID,1)bytesInDouble=struct.calcsize("d")data=(192-bytesInDouble)*"Q"data=struct.pack("d",time.time())+data#Calculatethechecksumonthedataandthedummyheader.myChecksum=checksum(header+data)#Nowthatwehavetherightchecksum,weputthatin.It'sjusteasier#tomakeupanewheaderthantostuffitintothedummy.ifsys.platform=='darwin':myChecksum=socket.htons(myChecksum)&0xffffelse:myChecksum=socket.htons(myChecksum)header=struct.pack("bbHHh",ICMP_ECHO_REQUEST,0,myChecksum,ID,1)packet=header+datamySocket.sendto(packet,(destAddr,1))#Don'tknowaboutthe1defdoOne(destAddr,timeout=10):#Returnseitherthedelay(inseconds)ornoneontimeout.icmp=socket.getprotobyname("icmp")print(socket.IPPROTO_ICMP==icmp)mySocket=socket.socket(socket.AF_INET,socket.SOCK_RAW,icmp)myID=os.getpid()&0xFFFFsendOnePing(mySocket,destAddr,myID)delay=receiveOnePing(mySocket,myID,timeout)mySocket.close()returndelaydefping(host,timeout=1):dest=socket.gethostbyname(host)print(dest)delay=doOne(dest,timeout)returndelayif__name__=='__main__':print(ping("127.0.0.1",3))#!/usr/bin/envpythonimportsocketfromtypingimportListfromheadersimportip_header,icmp_header#socketobjectusinganIPV4address,usingonlyrawsocketaccess,set#ICMPprotocolping_sock=socket.socket(socket.AF_INET,socket.SOCK_RAW,socket.IPPROTO_ICMP)packets:List[bytes]=[]whilelen(packets)<1:recPacket,addr=ping_sock.recvfrom(1024)ip=ip_header(recPacket[:20])icmp=icmp_header(recPacket[20:28])print(ip)print()print(icmp)print("\n")packets.append(recPacket)#!/usr/bin/envpythonimportsocketimportstructimportosimporttimeimportarraydefcalculateChecksum(pkt):#checksumfunctionfromscapyproject"""Thisisthechecksumfunctionfromthescapymodule."""iflen(pkt)%2==1:#ifpackethadoddlengthpadwithanullbytepkt+=b"\0"s=sum(array.array("H",pkt))s=(s>>16)+(s&0xffff)s+=s>>16s=~s#^^onescomplementsumofthepairsofbytesreturn(((s>>8)&0xff)|s<<8)&0xffff#s>>8movetheleftmosteightbytesintothefirstbyte#and-ingthatwith0xFFtruncatesanydatathatpastthefirst8bytes#i.e.01101001,11110000=>00000000,01101001#or-ingthatwiths<<8andthenandingitplacesthesecondbyteinthe#firstplacesandtruncatestheremainder,leavingjustthetwobytes#switchedICMP_ECHO_REQUEST=8#opensarawsocketfortheICMPprotocolping_sock=socket.socket(socket.AF_INET,socket.SOCK_RAW,socket.IPPROTO_ICMP)#allowsmanualIPheadercreation#ping_sock.setsockopt(socket.SOL_IP,socket.IP_HDRINCL,1)ID=os.getpid()&0xFFFF#thetwozerosarethecodeandthedummychecksum,theoneisthe#sequencenumberdummy_header=struct.pack("bbHHh",ICMP_ECHO_REQUEST,0,0,ID,1)data=struct.pack("d",time.time())+\bytes((192-struct.calcsize("d"))*"A","ascii")#thedatatosendinthepacketchecksum=socket.htons(calculateChecksum(dummy_header+data))#calculatesthechecksumforthepacketandpsuedoheaderheader=struct.pack("bbHHh",ICMP_ECHO_REQUEST,0,checksum,ID,1)#packsthepacketheaderpacket=header+data#concatonatestheheaderandthedatatoformthefinalpacket.ping_sock.sendto(packet,("127.0.0.1",1))#sendsthepackettolocalhostimportstructimportsocketfromtypingimportDictclassip_header:"""Aclassforparsing,storinganddisplayingdatafromanIPheader."""def__init__(self,header:bytes):#firstunpacktheIPheader(ip_hp_ip_v,ip_dscp_ip_ecn,ip_len,ip_id,ip_flgs_ip_off,ip_ttl,ip_p,ip_sum,ip_src,ip_dst)=struct.unpack('!BBHHHBBHII',header)#nowdealwiththesub-bytesizedcomponentshl_v=f"{ip_hp_ip_v:08b}"ip_v=int(hl_v[:4],2)ip_hl=int(hl_v[4:],2)#splitshl_vinip_vandip_hlwhichstoretheIPversionnumberand#headerlengthrespectivelydscp_ecn=f"{ip_dscp_ip_ecn:08b}"ip_dscp=int(dscp_ecn[:6],2)ip_ecn=int(dscp_ecn[6:],2)#splitsdscp_ecnintoip_dscpandip_ecn#whicharetwoofthecompenents#inanIPheaderflgs_off=f"{ip_flgs_ip_off:016b}"ip_flgs=int(flgs_off[:3],2)ip_off=int(flgs_off[3:],2)#splitsflgs_offintoip_flgsandip_offwhichrepresenttheipheader#flagsandthedataoffsetsrc_addr=socket.inet_ntoa(struct.pack('!I',ip_src))dst_addr=socket.inet_ntoa(struct.pack('!I',ip_dst))self.version:int=ip_vself.header_length:int=ip_hlself.dscp:int=ip_dscpself.ecn:int=ip_ecnself.len:int=ip_lenself.id:int=ip_idself.flags:int=ip_flgsself.data_offset:int=ip_offself.time_to_live:int=ip_ttlself.protocol:int=ip_pself.checksum:int=ip_sumself.source:str=src_addrself.destination:str=dst_addrdef__repr__(self):return"\n\t".join(("IPheader:",f"Version:[{self.version}]",f"InternetHeaderLength:[{self.header_length}]",f"DifferentiatedServicesPointCode:[{self.dscp}]",f"ExplicitCongestionNotification:[{self.ecn}]",f"TotalLength:[{self.len}]",f"Identification:[{self.id:04x}]",f"Flags:[{self.flags:03b}]",f"FragmentOffset:[{self.data_offset}]",f"TimeToLive:[{self.time_to_live}]",f"Protocol:[{self.protocol}]",f"HeaderChecksum:[{self.checksum:04x}]",f"SourceAddress:[{self.source}]",f"DestinationAddress:[{self.destination}]"))classicmp_header:"""Aclassforparsing,storinganddisplayingdatafromanIPheader."""#relatesthetypeandcodetothemessagemessages:Dict[int,Dict[int,str]]={0:{0:"Echoreply."},3:{0:"Destinationnetworkunreachable.",1:"Destinationhostunreachable",2:"Destinationprotocolunreachable",3:"Destinationportunreachable",4:"Fragmentationrequired,andDFflagset.",5:"Sourceroutefailed.",6:"Destinationnetworkunknown.",7:"Destinationhostunknown.",8:"Sourcehostisolated.",9:"Networkadministrativelyprohibited.",10:"Hostadministrativelyprohibited.",11:"NetworkunreachableforToS.",12:"HostunreachableforToS.",13:"Communicationadministrativelyprohibited.",14:"Hostprecedenceviolation.",15:"Precedencecutoffineffect."},4:{0:"Sourcequench."},5:{0:"Redirectdatagramforthenetwork",1:"Redirectdatagramforthehost.",2:"RedirectdatagramfortheToS&network.",3:"RedirectdatagramfortheToS&host."},8:{0:"Echorequest."},9:{0:"Routeradvertisment"},10:{0:"Routerdiscovery/selection/solicitation."},11:{0:"TTLexpiredintransit",1:"Fragmentreassemblytimeexceeded."},12:{0:"BadIPheader:pointerindicateserror.",1:"BadIPheader:missingarequiredoption.",2:"BadIPheader:Badlength."},13:{0:"Timestamp"},14:{0:"Timestampreply"},15:{0:"Informationrequest."},16:{0:"Informationreply."},17:{0:"Addressmaskrequest."},18:{0:"Addressmaskreply."}}def__init__(self,header:bytes):(ICMP_type,code,csum,remainder)=struct.unpack('!bbHI',header)self.type:int=ICMP_typeself.code:int=codeself.checksum:int=csumself.message:strtry:self.message=icmp_header.messages[self.type][self.code]exceptKeyError:#ifwecan'tassignamessagethenjustsetadescription#astowhatcausedthefailure.self.message=f"Failedtoassignmessage:({self.type/self.code})"self.id:intself.sequence:intifself.typein{0,8}:self.id=remainder>>16self.sequence=remainder&0xFFFFelse:self.id=-1self.sequence=-1def__repr__(self):return"\n\t".join(("ICMPheader:",f"Message:[{self.message}]",f"Type:[{self.type}]",f"Code:[{self.code}]",f"Checksum:[{self.checksum:04x}]",f"ID:[{self.id}]",f"Sequence:[{self.sequence}]"))classudp_header:def__init__(self,header:bytes):#parseudpheader(src_port,dest_port,length,checksum)=struct.unpack("!HHHH",header)self.src:int=src_portself.dest:int=dest_portself.length:int=lengthself.checksum:int=checksumdef__repr__(self):return"\n\t".join("UDPheader:",f"Sourceport:{self.src}",f"Destinationport:{self.dest}",f"Length:{self.length}",f"Checksum:{self.checksum:04x}")importarrayimportsocketimportstructimportselectimporttimefromcontextlibimportclosingfromfunctoolsimportsingledispatchfromitertoolsimportislice,cyclefromsysimportstderrfromtypingimportListdefeprint(*args,**kwargs):"""Mirrorsprintexactlybutprintstostderrinsteadofstdout."""print(*args,file=stderr,**kwargs)deflong_to_dot(long:int)->str:"""TakeinanIPaddressinpacked32bitintformandreturnthataddressindotnotation.i.e.long_to_dot(0x7F000001)=127.0.0.1"""#thesearelongformvaluesfor0.0.0.0#and255.255.255.255ifnot0<=long<=0xFFFFFFFF:raiseValueError(f"InvalidlongformIPaddress:[{long:08x}]")else:#shiftthelongformIPalong0,8,16,24bits#takeonlythefirst8bitsofthenewlyshiftednumber#castthemtoastringandjointhemwith'.'sreturn".".join(str((long>>(8*(3-i)))&0xFF)foriinrange(4))defdot_to_long(ip:str)->int:"""Takeanipaddressindotnotationandreturnthepacked32bitintversioni.e.dot_to_long("127.0.0.1")=0x7F000001"""#dotformips:a.b.c.dmusthaveeach#part(a,b,c,d)between0and255,#otherwisetheyareinvalidparts=[int(i)foriinip.split(".")]ifnotall(0<=int(i)<=255foriinparts):raiseValueError(f"InvaliddotformIPaddress:[{ip}]")else:#foreachpartofthedottedIPaddress#bitshiftlefteachpartbyeighttimes#threeminusit'sposition.Thisputsthebits#fromeachpartintherightplaceinthefinalsum#a.b.c.d->a<<3*8+b<<2*8+c<<1*8+d<<0*8returnsum(part<<((3-i)*8)fori,partinenumerate(parts))@singledispatchdefis_valid_ip(ip)->bool:"""checkswhetheragivenIPaddressisvalid."""@is_valid_ip.registerdef_(ip:int):#thisistheintoverloadvariantof#theis_valid_ipfunction.try:#trytoturnthelongformipaddress#toadotformone,ifitfails,#thenreturnFalse,elsereturnTruelong_to_dot(ip)returnTrueexceptValueError:returnFalse#thetypeignorecommentisrequiredtostop#mypyexplodingoverthefactIhavedefined`_`twice.@is_valid_ip.register#type:ignoredef_(ip:str):#thisisthestringoverloadvariant#oftheis_valid_ipfunction.try:#trytoturnthedotformipaddress#toalongformone,ifitfails,#thenreturnFalse,elsereturnTruedot_to_long(ip)returnTrueexceptValueError:returnFalsedefis_valid_port_number(port_num:int)->bool:"""Checkswhetherthegivenportnumberisvalidi.e.between0and65536."""#portnumbersmustbebetween0and65535(2^16-1)if0<=port_num<2**16:returnTrueelse:returnFalsedefip_range(ip:str,network_bits:int)->List[str]:"""TakesaClasslessInterDomainRouting(CIDR)addresssubnetspecificationandreturnsthelistofaddressesspecifiedbytheIP/networkbitsformat.Ifthenumberofnetworkbitsisnotbetween0and32itraisesanerror.IftheIPaddressisinvalidaccordingtois_valid_ipitraisesanerror."""ifnot0<=network_bits<=32:raiseValueError(f"Invalidnumberofnetworkbits:[{network_bits}]")ifnotis_valid_ip(ip):raiseValueError(f"InvalidIPaddress:[{ip}]")#gettheipaslongformwhichisuseful#lateronforusingbitwiseoperators#toisolateonlytheconstant(network)bitsip_long=dot_to_long(ip)#generatethebitmaskwhichspecifies#whichbitstokeepandwhichtodiscardmask=int(f"{'1'*network_bits:0<32s}",2)lower_bound=ip_long&maskupper_bound=ip_long|(mask^0xFFFFFFFF)#turnallthelongformIPaddressesbetween#thelowerandupperboundintodotformreturn[long_to_dot(long_ip)forlong_ipinrange(lower_bound,upper_bound+1)]defget_local_ip()->str:"""Connectstothegoogle.comwithUDPandgetstheIPaddressusedtoconnect(thelocaladdress)."""withclosing(socket.socket(socket.AF_INET,socket.SOCK_DGRAM))ass:s.connect(("google.com",80))ip,_=s.getsockname()returnipdefget_free_port()->int:"""Attemptstobindtoport0whichassignsafreeportnumbertothesocket,thesocketisthenclosedandtheportnumberassignedisreturned."""withclosing(socket.socket(socket.AF_INET,socket.SOCK_STREAM))ass:s.bind(('',0))_,port=s.getsockname()returnport#TODOrewritethisyourself...defip_checksum(pkt:bytes)->int:"""ip_checksumtakesapacketandcalculatestheIPchecksumforthegivenpacket.ThischecksumfunctionistakenfromthescapypythonlibrarywhichisreleasedundertheopensourceGPLV2.commentsaremine."""#ifthelengthofthepacketisnot#divisibleby2thenappendanullbyteiflen(pkt)%2==1:pkt+=b"\0"#findthesumofthebyteofthepacket#treatingthemasunsignedshorts-2byteslongs=sum(array.array("H",pkt))#thislinetakesthebitsafterthe16th#bitfromtherightandaddsittothefirst16bits.#[<-16][16-8][8-0]->[16-0]+[<-16]s=(s>>16)+(s&0xffff)#addonallthebitspast16agains+=s>>16#bitwisenegateeachbits=~s#([<-8]OR[<-0][0*8])AND[1*16]return(((s>>8)&0xff)|s<<8)&0xffffdefmake_icmp_packet(ID:int)->bytes:"""TakesanargumentoftheprocessIDofthecallingprocess.ReturnsanICMPECHOREQUESTpacketcreatedwiththisID"""ICMP_ECHO_REQUEST=8#packtheinformationforthedummyheaderneeded#fortheIPchecksumdummy_header=struct.pack("bbHHh",ICMP_ECHO_REQUEST,0,0,ID,1)#packthecurrenttimeintoadoubletime_bytes=struct.pack("d",time.time())#definethebytestorepeatinthedatasectionofthepacket#thismakesthepacketseasilyidentifiableinpacketcaptures.bytes_to_repeat_in_data=map(ord,"y33t")#calculatethenumberofbytesleftfordatadata_bytes=(192-struct.calcsize("d"))#firstpackthecurrenttimeintothestartofthedatasection#thepacktheidentifiabledataintotherestdata=(time_bytes+bytes(islice(cycle(bytes_to_repeat_in_data),data_bytes)))#gettheIPchecksumforthedummyheaderanddata#andswitchthebytesintotheorderexpectedbythenetworkchecksum=socket.htons(ip_checksum(dummy_header+data))#packtheheaderwiththecorrectchecksumandinformationheader=struct.pack("bbHHh",ICMP_ECHO_REQUEST,0,checksum,ID,1)#concatonatetheheaderbytesandthedatabytesreturnheader+datadefmake_tcp_packet(src:int,dst:int,from_address:str,to_address:str,flags:int)->bytes:"""Takesinthesourceanddestinationport/ipaddressreturnsatcppacket.flags:2=>SYN18=>SYN:ACK4=>RST"""#validatethattheinformationpassedinisvalidifflagsnotin{2,18,4}:raiseValueError(f"Flagsmustbeoneof2:SYN,18:SYN,ACK,4:RST.not:[{flags}]")ifnotis_valid_ip(from_address):raiseValueError(f"InvalidsourceIPaddress:[{from_address}]")ifnotis_valid_ip(to_address):raiseValueError(f"InvaliddestinationIPaddress:[{to_address}]")ifnotis_valid_port_number(src):raiseValueError(f"Invalidsourceport:[{src}]")ifnotis_valid_port_number(dst):raiseValueError(f"Invaliddestinationport:[{dst}]")#turntheipaddressesintolongformsrc_addr=dot_to_long(from_address)dst_addr=dot_to_long(to_address)seq=ack=urg=0data_offset=6<<4window_size=1024max_segment_size=(2,4,1460)#packthedummyheaderneededforthechecksumcalculationdummy_header=struct.pack("!HHIIBBHHHBBH",src,dst,seq,ack,data_offset,flags,window_size,0,urg,*max_segment_size)#packthepsuedoheaderthatisalsoneededforthechecksum#justbecauseTCPandwhynotpsuedo_header=struct.pack("!IIBBH",src_addr,dst_addr,0,6,len(dummy_header))checksum=ip_checksum(psuedo_header+dummy_header)#packthefinalTCPpacketwiththerelevantdataandchecksumreturnstruct.pack("!HHIIBBHHHBBH",src,dst,seq,ack,data_offset,flags,window_size,checksum,urg,*max_segment_size)defmake_udp_packet(src:int,dst:int,from_address:str,to_address:str)->bytes:"""Takesin:sourceIPaddressandport,destinationIPaddressandport.Returns:aUDPpacketwiththoseproperties.theIPaddressesareneededforcalculatingthechecksum."""#validatedatapassedinifnotis_valid_ip(from_address):raiseValueError(f"InvalidsourceIPaddress:[{from_address}]")ifnotis_valid_ip(to_address):raiseValueError(f"InvaliddestinationIPaddress:[{to_address}]")ifnotis_valid_port_number(src):raiseValueError(f"Invalidsourceport:[{src}]")ifnotis_valid_port_number(dst):raiseValueError(f"Invaliddestinationport:[{dst}]")UDP_length=8#packthedummyandpsuedoheadersneededforthechecksumdummy_header=struct.pack("!HHHH",src,dst,UDP_length,0)#17istheUDPprotocolnumberpsuedo_header=struct.pack("!IIBBH",src,dst,0,17,len(dummy_header))checksum=ip_checksum(psuedo_header+dummy_header)#packthedataandchecksumintotherightformat#andreturnthepackedbytesreturnstruct.pack("!HHHH",src,dst,UDP_length,checksum)defwait_for_socket(sock:socket.socket,wait_time:float)->float:"""Waitforwait_timesecondsoruntilthesocketisreadable.IfthesocketisreadablereturnatupleofthesocketandthetimetakenotherwisereturnNone."""start=time.time()is_socket_readable=select.select([sock],[],[],wait_time)taken=time.time()-startifis_socket_readable[0]==[]:returnfloat(-1)else:returntaken#!/use/bin/envpythonfromip_utilsimport(dot_to_long,long_to_dot)#!/usr/bin/envpythonimportip_utilsimportstructimportsocketimporttimefromcontextlibimportclosingfromheadersimporticmp_header,ip_headerfromitertoolsimportrepeatfrommathimportlog10,floorfrommultiprocessingimportPoolfromosimportgetpidfromtypingimportList,Tupledefsig_figs(x:float,n:int)->float:"""roundsxtonsignificantfigures.sig_figs(1234,2)=1200.0"""returnround(x,n-(1+int(floor(log10(abs(x))))))defrecieved_ping_from_addresses(ID:int,timeout:float)->List[Tuple[str,float,ip_header]]:"""TakesinaprocessidandatimeoutandreturnsalistofaddresseswhichsentICMPECHOREPLYpacketswiththepackedidmatchingIDinthetimegivenbytimeout."""ping_sock=socket.socket(socket.AF_INET,socket.SOCK_RAW,socket.IPPROTO_ICMP)#opensarawsocketforsendingICMPprotocolpacketstime_remaining=timeoutaddresses=[]whileTrue:time_waiting=ip_utils.wait_for_socket(ping_sock,time_remaining)#time_waitingstoresthetimethesockettooktobecomereadable#orreturnsminusoneifitranoutoftimeiftime_waiting==-1:breaktime_recieved=time.time()#storethetimethepacketwasrecievedrecPacket,addr=ping_sock.recvfrom(1024)#recievethepacketip=ip_header(recPacket[:20])#unpacktheIPheaderintoitsrespectivecomponentsicmp=icmp_header(recPacket[20:28])#unpackthetimefromthepacket.time_sent=struct.unpack("d",recPacket[28:28+struct.calcsize("d")])[0]#unpackthevalueforwhenthepacketwassenttime_taken:float=time_recieved-time_sent#calculatetheroundtriptimetakenforthepacketificmp.id==ID:#ifthepingwassentfromthismachinethenaddittothelistof#responsesip_address,port=addraddresses.append((ip_address,time_taken,ip))eliftime_remaining<=0:breakelse:continue#returnalistofalltheaddessesthatrepliedtoourICMPechorequest.returnaddresseswithclosing(socket.socket(socket.AF_INET,socket.SOCK_RAW,socket.IPPROTO_ICMP))asping_sock:ip_addresses=ip_utils.ip_range("192.168.1.0",24)#generatetherangeofIPaddressestoscan.local_ip=ip_utils.get_local_ip()#getthelocalipaddressaddresses=[ipforipinip_addressesif(notip.endswith(".0")andnotip.endswith(".255")andip!=local_ip)]#initialiseaprocesspoolp=Pool(1)#getthelocalprocessidforuseincreatingpackets.ID=getpid()&0xFFFF#runtherecieved_ping_from_addressesfunctionasynchronouslyreplied=p.apply_async(recieved_ping_from_addresses,(ID,2))foraddressinzip(addresses,repeat(1)):try:packet=ip_utils.make_icmp_packet(ID)print(f"scanning{address}")ping_sock.sendto(packet,address)exceptPermissionError:ip_utils.eprint("rawsocketsrequirerootpriveleges,exiting")raisep.close()p.join()#closeandjointheprocesspooltosothatallthevalues#havebeenreturnedandthepoolclosedhosts_up=replied.get()#getthelistofaddressesthatrepliedtotheechorequestfromthe#listenerfunctionprint("\n".join(f"host:[{host}]\t"+"respondedtoanICMPECHOREQUESTin"+f"{str(sig_figs(taken,2))+'s':<10s}"+f"ttl:[{ip_head.time_to_live}]"forhost,taken,ip_headinhosts_up))#!/usr/bin/envpythonfromip_utilsimport(ip_range)importreif__name__=='__main__':fromargparseimportArgumentParserparser=ArgumentParser()parser.add_argument("ip_subnet",help="TheCIDRformip/subnetthatyouwishtoprint"+"theIPaddressesspecifiedby.")args=parser.parse_args()CIDR_regex=re.compile(r"(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/\d+)")search=CIDR_regex.search(args.ip_subnet)ifsearch:ip,network_bits=search.group(1).split("/")print("\n".join(ip_range(ip,int(network_bits))))#!/usr/bin/python3fromtypingimportList,Iterabledefconnect_scan(address:str,ports:Iterable[int])->List[int]:importsocketfromcontextlibimportclosingopen_ports:List[int]=[]forportinports:#loopthrougheachportinthelistofportstoscantry:withclosing(socket.socket(socket.AF_INET,socket.SOCK_STREAM))ass:#openanIPV4TCPsockets.connect((address,port))#attempttoconnectthenewlycreatedsockettothetarget#addressandportopen_ports.append(port)#iftheconnectionwassuccessfulthenaddtheporttothe#listofopenportsexceptConnectionRefusedError:passreturnopen_portsif__name__=="__main__":open_ports=connect_scan("127.0.0.1",range(65535))print("\n".join(map(lambdax:f"port:[{x}]\tisopen",open_ports)))#!/usr/bin/python3fromcontextlibimportclosingimportsocketLOCAL_IP="192.168.1.159"PORT=22address=("127.0.0.1",22)withclosing(socket.socket(socket.AF_INET,socket.SOCK_STREAM))ass:try:s.connect(address)print(f"connectiononport{PORT}succedded")exceptConnectionRefusedError:print(f"printport{PORT}isclosed")#!/usr/bin/python3.7frommultiprocessingimportPoolfromtypingimportList,Tuple,Iterableimportstructfromcontextlibimportclosingimportsocketimportip_utilsdefsyn_listener(address:Tuple[str,int],timeout:float)->List[int]:"""ThisfunctionisrunasynchronouslyandlistensforTCPACKresponsestothesentTCPSYNmsg."""print(f"address:[{address}]\ntimeout:[{timeout}]")open_ports:List[int]=[]withclosing(socket.socket(socket.AF_INET,socket.SOCK_RAW,socket.IPPROTO_TCP))ass:s.bind(address)#bindtherawsockettothelisteningaddresstime_remaining=timeoutprint("startedlistening")whileTrue:time_taken=ip_utils.wait_for_socket(s,time_remaining)#waitforthesockettobecomereadableiftime_taken==-1:breakelse:time_remaining-=time_takenpacket=s.recv(1024)#recievethepacketdatasrc_prt,dst_prt,seq,ack,data_offset,flags,window_size,\checksum,urg=struct.unpack("!HHIIBBHHH",packet[20:40])#unpackthedatafromtheTCPheadersectionifflags==int("00010010",2):#synackopen_ports.append(src_prt)#checkthattheheadercontainedtheTCPACKflagandifit#didappenditelse:continueprint("finishedlistening")returnopen_portsdefsyn_scan(dest_ip:str,portlist:Iterable[int])->List[int]:src_port=ip_utils.get_free_port()#requestalocalporttoconnectfromlocal_ip=ip_utils.get_local_ip()p=Pool(1)listener=p.apply_async(syn_listener,((local_ip,src_port),5))#starttheTCPACKlistenerinthebackgroundprint("startingscan")forportinportlist:packet=ip_utils.make_tcp_packet(src_port,port,local_ip,dest_ip,2)#createaTCPpacketwiththesynflagwithclosing(socket.socket(socket.AF_INET,socket.SOCK_RAW,socket.IPPROTO_TCP))ass:s.sendto(packet,(dest_ip,port))#sendthepackettoitsdestinationprint("finishedscan")p.close()p.join()open_ports=listener.get()#collectthelistofportsthatrespondedtotheTCPSYNmessageprint(open_ports)returnopen_portsdest_ip="127.0.0.1"syn_scan(dest_ip,range(2**16))#!/usr/bin/python3.7fromcontextlibimportclosingimportsocketimportip_utilsdest_port=22src_port=ip_utils.get_free_port()local_ip=ip_utils.get_local_ip()dest_ip="192.168.1.159"local_ip=dest_ip="127.0.0.1"loc_long=ip_utils.dot_to_long(local_ip)SYN=2RST=4withclosing(socket.socket(socket.AF_INET,socket.SOCK_RAW,socket.IPPROTO_TCP))ass:tcp_packet=ip_utils.make_tcp_packet(src_port,dest_port,local_ip,dest_ip,SYN)iftcp_packetisnotNone:s.sendto(tcp_packet,(dest_ip,dest_port))else:print(f"Couldn'tmakeTCPpacketwithsuppliedarguments:",f"sourceport:[{src_port}]",f"destinationport:[{dest_port}]",f"localip:[{local_ip}]",f"destinationip:[{dest_ip}]",f"SYNflag:[{SYN}]",sep="\n")fromip_utilsimport(dot_to_long,long_to_dot,ip_range,is_valid_ip,is_valid_port_number)deftest_dot_to_long():assert(dot_to_long("127.0.0.1")==0x7F000001)deftest_long_to_dot():assert(long_to_dot(0x7F000001)=="127.0.0.1")deftest_is_valid_ip():assert(is_valid_ip(0x7F000001)andis_valid_ip("127.0.0.1")andnotis_valid_ip("0.0.0.0.0")andnotis_valid_ip(0xFF_FF_FF_FF_FF))deftest_is_valid_port_number():assert(is_valid_port_number(0)andis_valid_port_number(65535)andnotis_valid_port_number(-1)andnotis_valid_port_number(2**16))deftest_ip_range():assert(ip_range("192.168.1.0",28)==["192.168.1.0","192.168.1.1","192.168.1.2","192.168.1.3","192.168.1.4","192.168.1.5","192.168.1.6","192.168.1.7","192.168.1.8","192.168.1.9","192.168.1.10","192.168.1.11","192.168.1.12","192.168.1.13","192.168.1.14","192.168.1.15"])#!/usr/bin/pythonfromcontextlibimportclosingimportip_utilsimportsocketdest_ip="192.168.1.1"dest_port=68local_ip=ip_utils.get_local_ip()local_port=ip_utils.get_free_port()local_ip=dest_ip="127.0.0.1"address=(dest_ip,dest_port)withclosing(socket.socket(socket.AF_INET,socket.SOCK_RAW,socket.IPPROTO_UDP))ass:try:pkt=ip_utils.make_udp_packet(local_port,dest_port,local_ip,dest_ip)ifpktisnotNone:packet=bytes(pkt)s.sendto(packet,address)else:print("Errormakingpacket.",f"localport:[{local_port}]",f"destinationport:[{dest_port}]",f"localip:[{local_ip}]",f"destinationip:[{dest_ip}]",sep="\n")exceptsocket.error:raise#!/usr/bin/envpythonimportsocketfromcontextlibimportclosingwithclosing(socket.socket(socket.AF_INET,socket.SOCK_DGRAM))ass:s.bind(("127.0.0.1",6969))print("openedport6969onlocalhost")whileTrue:data,addr=s.recvfrom(1024)s.sendto(bytes("Wellhellothereyoungone.","utf-8"),addr)#!/usr/bin/envpythonimportip_utilsimportsocketimporttimefromcollectionsimportdefaultdictfromcontextlibimportclosingfromheadersimport(icmp_header,ip_header,udp_header)frommultiprocessingimportPoolfromtypingimportSet,DefaultDictdefudp_listener(dest_ip:str,timeout:float)->Set[int]:"""ThislistenerdetectsUDPpacketsfromdest_ipinthegiventimespan,allportsthatsenddirectrepliesaremarkedasbeingopen.Returnsalistofopenports."""time_remaining=timeoutports:Set[int]=set()withsocket.socket(socket.AF_INET,socket.SOCK_RAW,socket.IPPROTO_UDP)ass:whileTrue:time_taken=ip_utils.wait_for_socket(s,time_remaining)iftime_taken==-1:breakelse:time_remaining-=time_takenpacket=s.recv(1024)ip=ip_header(packet[:20])udp=udp_header(packet[20:28])#unpacktheUDPheaderifdest_ip==ip.sourceandip.protocol==17:ports.add(udp.src)returnportsdeficmp_listener(src_ip:str,timeout=2)->int:"""ThislistenerdetectsICMPdestinationunreachablepacketsandreturnstheicmpcode.Thisislaterusedtomarkthemaseitherclose,open|filtered,filtered.3->closed0|1|2|9|10|13->filtered-1->errorwithargumentsopen|filteredmeansthattheyareeitheropenorfilteredbutreturnnothing."""ping_sock=socket.socket(socket.AF_INET,socket.SOCK_RAW,socket.IPPROTO_ICMP)#openrawsockettolistenforICMPdestinationunrechablepacketstime_remaining=timeoutcode=-1whileTrue:time_waiting=ip_utils.wait_for_socket(ping_sock,time_remaining)#waitforsockettobereadableiftime_waiting==-1:breakelse:time_remaining-=time_waitingrecPacket,addr=ping_sock.recvfrom(1024)#recievethepacketip=ip_header(recPacket[:20])icmp=icmp_header(recPacket[20:28])valid_codes=[0,1,2,3,9,10,13]if(ip.source==src_ipandicmp.type==3andicmp.codeinvalid_codes):code=icmp.codebreakeliftime_remaining<=0:breakelse:continueping_sock.close()returncodedefudp_scan(dest_ip:str,ports_to_scan:Set[int])->DefaultDict[str,Set[int]]:"""TakesinadestinationIPaddressineitherdotorlongformandalistofportstoscan.SendsUDPpacketstoeachportspecifiedinportlistandusesthelistenerstomarkthemasopen,open|filtered,filtered,closedtheyaremarkedopen|filteredifnoresponseisrecievedatall."""local_ip=ip_utils.get_local_ip()local_port=ip_utils.get_free_port()#getlocalipaddressandportnumberports:DefaultDict[str,Set[int]]=defaultdict(set)ports["REMAINING"]=ports_to_scanp=Pool(1)udp_listen=p.apply_async(udp_listener,(dest_ip,4))#starttheUDPlistenerwithclosing(socket.socket(socket.AF_INET,socket.SOCK_RAW,socket.IPPROTO_UDP))ass:for_inrange(2):#repeat3timesbecauseUDPscanningcomes#withahighchanceofpacketlossfordest_portinports["REMAINING"]:try:packet=ip_utils.make_udp_packet(local_port,dest_port,local_ip,dest_ip)#createtheUDPpackettosends.sendto(packet,(dest_ip,dest_port))#sendthepackettothecurrentlyscanningaddressexceptsocket.error:packet_bytes="".join(f"{byte:02x}"forbyteinpacket)print("Thesocketmodulessendtomethodwiththefollowing","argumentresultinginasocketerror.",f"\npacket:[{packet_bytes}]\n","address:[{dest_ip,dest_port}])")p.close()p.join()ports["OPEN"].update(udp_listen.get())ports["REMAINING"]-=ports["OPEN"]#onlyscantheportswhichweknowarenotopenwithclosing(socket.socket(socket.AF_INET,socket.SOCK_RAW,socket.IPPROTO_UDP))ass:fordest_portinports["REMAINING"]:try:packet=ip_utils.make_udp_packet(local_port,dest_port,local_ip,dest_ip)#makeanewUDPpacketp=Pool(1)icmp_listen=p.apply_async(icmp_listener,(dest_ip,))#starttheICMPlistenertime.sleep(1)s.sendto(packet,(dest_ip,dest_port))#sendpacketp.close()p.join()icmp_code=icmp_listen.get()#recieveICMPcodefromtheICMPlistenerificmp_codein{0,1,2,9,10,13}:ports["FILTERED"].add(dest_port)elificmp_code==3:ports["CLOSED"].add(dest_port)exceptsocket.error:packet_bytes="".join(map("{:02x}".format,packet))ip_utils.eprint("Thesocketmodulessendtomethodwiththefollowing","argumentresultinginasocketerror.",f"\npacket:[{packet_bytes}]\n","address:[{dest_ip,dest_port}])")#thiscreatesanewsetwhichcontainsalltheelementsthat#areinthelistofportstobescannedbuthavenotyet#beenclassifiedports["OPEN|FILTERED"]=(ports["REMAINING"]-ports["OPEN"]-ports["FILTERED"]-ports["CLOSED"])#setcomprehensiontoupdatethelistofopenfilteredportsreturnportsports=udp_scan("127.0.0.1",{22,68,53,6969})print(f"Openports:{ports['OPEN']}")print(f"Openorfilteredports:{ports['OPEN|FILTERED']}")print(f"Filteredports:{ports['FILTERED']}")print(f"Closedports:{ports['CLOSED']}")#!/usr/bin/envpythonfromcollectionsimportdefaultdictfromcontextlibimportclosingfromdataclassesimportdataclassfromtypingimportDefaultDict,Set,Dictimportip_utilsimportreimportsocket@dataclassclassTarget:"""Thisclassholdsdataabouttargetstoscan.thedataclassdecoratorissimplyawayofpythonautomaticallywritingsomeofthebasicmethodsaclassforstoringdatahas,suchas__repr__forprintinginformationintheobjectetc."""address:stropen_ports:DefaultDict[str,Set[int]]open_filtered_ports:DefaultDict[str,Set[int]]classProbe:"""ThisclassrepresentstheProbedirectiveofthenmap-service-probesfile.Itholdsinformationsuchastheprotocoltouse,thestringtosend,theportstoscan,thetimetowaitforanullTCPtoreturnabanner,therarityoftheprobe(howoftenitwillreturnaresponse)andtheprobestotryifthisonefails."""#adefaultdictisonewhichtakesina#"defaultfactory"whichiscalledwhen#anewkeyisintroducedtothedict#inthiscasethedefaultfactoryis#thesetfunctionmeaningthatwhenI#doexclude[protocol].update(ports)#butexclude[protocol]hasnotyetbeendefined#itwillbedefinedasanemptyset#allowingmetoupdateitwithports.exclude:DefaultDict[str,Set[int]]=defaultdict(set)proto_to_socket_type:Dict[str,int]={"TCP":socket.SOCK_STREAM,"UDP":socket.SOCK_DGRAM}def__init__(self,protocol:str,probename:str,probestring:str):"""ThisistheinitialfunctionthatiscalledbytheconstructoroftheProbeclass,itisusedtodefinethevariablesthatarespecifictoeachinstanceoftheclass."""ifprotocolin{"TCP","UDP"}:self.protocol=protocolelse:raiseValueError(f"ProbeobjectmusthaveprotocolTCPorUDPnot{protocol}.")self.name=probenameself.string=probestringself.matches:Set[Match]=set()self.softmatches:Set[Softmatch]=set()self.ports:DefaultDict[str,Set[int]]=defaultdict(set)self.totalwaitms=6000self.tcpwrappedms=3000self.rarity=-1self.fallback:Set[str]=set()def__repr__(self):"""Thisisthefunctionthatiscalledwhensomethingtriestoprintaninstanceofthisclass.Itisusedtorevealinformationinternaltotheclass."""return",".join([f"Probe({self.protocol}",f"{self.name}",f"\"{self.string}\"",f"{len(self.matches)}matches",f"{len(self.softmatches)}softmatches",f"ports:{self.ports}",f"rarity:{self.rarity}",f"fallbacks:{self.fallback})"])defscan(self,target:Target):"""scantakesinanobjectofclassTargettoprobeandattemptstodetecttheversionofanyservicesrunningonthemachine."""#thisconstructsthesetofallports,#thatareeitheropenoropen_filtered,#andareinthesetofportstoscanfor#thisparticularprobe,thismeansthat,#weareonlyconnectingtoportsthatwe#knowarenotclosedandarenottobeexcluded.ports_to_scan:Set[int]=((target.open_filtered_ports[self.protocol]|target.open_ports[self.protocol]|self.ports["ANY"])&self.ports[self.protocol])-Probe.exclude[self.protocol]-Probe.exclude["ANY"]forportinports_to_scan:withclosing(socket.socket(socket.AF_INET,self.proto_to_socket_type[self.protocol]))assock:sock.send(bytes(self.string,"utf-8"))#TODOmainscanninglogicclassMatch:"""Thisclassholdsinformationforthematchdirective.Thisincludesoptionalversioninfoaswellasaservice,apatterntomatchtheresponseagainstandsomepatternoptions."""version_info:DefaultDict[str,str]=defaultdict(str)letter_to_name={"p":"vendorproductname","v":"version","i":"info","h":"hostname","o":"operatingsystem","d":"devicetype"}def__init__(self,service:str,pattern:str,pattern_options:str):self.service:str=serviceself.pattern:str=pattern#inlineregexoptionsarethecoolself.pattern_options:str=pattern_optionsdefadd_version_info(self,version_string:str):#thisregularexpressionmatchesonecharacterfrompvihod#followedbya/thenitnon-greedilymatchesatleastoneof#anycharacterfollowedbyanotherslashregex=re.compile(r"[pvihod]/.+?/")#findalltheadditionalfieldsanditerateoverthemfields=regex.findall(version_string)forfieldinfields:#addthefieldinformationtothematchobjectself.version_info[Match.letter_to_name[field[0]]]=field[2:-1]classSoftmatch:"""Thisclassholdsinfomationforthesortmatchdirective.Suchastheservice,theregexpatternandthepatternoptions."""def__init__(self,service:str,pattern:str,pattern_options:str):self.service:str=serviceself.pattern:str=patternself.pattern_options:str=pattern_options#!/usr/bin/envpythonimportdirectivesfromtypingimportDict,Set,Pattern,Tuple,DefaultDictfromfunctoolsimportreducefromcollectionsimportdefaultdictimportreimportoperatordefparse_ports(portstring:str)->DefaultDict[str,Set[int]]:"""Thisfunctiontakesinaportdirectiveandreturnsasetoftheportsspecified.AsetisusedbecauseitisO(1)forcontainsoperationsasopposedforO(N)forlists."""#matchesboththenum-numportrangeformat#andtheplainnumportspecification#num-numformmustcomefirstotherwiseitbreaks.proto_regex=re.compile(r"([TU]):?([0-9,-]+)")#THESPACEISIMPORTANT!!!#itallowsportsspecifiedbeforeTCP/UDPports#tobespecifiedgloballypair_regex=re.compile(r"(\d+)-(\d+)")single_regex=re.compile(r"(\d+)")ports:DefaultDict[str,Set[int]]=defaultdict(set)#searchescontainstheresultoftryingthepair_regex#searchagainstallofthecommandseperated#portstringsforprotocol,portstringinproto_regex.findall(portstring):pairs=pair_regex.findall(portstring)#foreachpairofnumbersinthepairslist#seperateeachnumberandcastthemtoint#thengeneratetherangeofnumbersfromx[0]#tox[1]+1thencastthisrangetoalist#and"reduce"thelistoflistsbyjoiningthem#withoperator.ior(inclusiveor)andthenlet#portsbethesetofalltheportsinthatlist.proto_map={"":"ANY","U":"UDP","T":"TCP"}ifpairs:#afunctiontogofromaportpairi.e.(80-85)#tothesetofspecifiedports:{80,81,82,83,84,85}defpair_to_ports(pair:Tuple[int,int])->Set[int]:start,end=pairreturnset(range(start,end+1))#portscontainsthesetofallANY/TCP/UDPspecifiedportsports[proto_map[protocol]]=set(reduce(operator.ior,map(pair_to_ports,pairs)))print(ports)singles=single_regex.findall(portstring)#foreachoftheportsthatarespecifiedontheirown#castthemtointandupdatethesetofallportswith#thatlist.ports[proto_map[protocol]].update(map(int,singles))returnports#TODOContinuereadabilityrefactoraboveandinallotherfiles.defparse_probes(probe_file:str)->Dict[str,directives.Probe]:"""Extractsalloftheprobedirectivesfromthefilepointedtobyprobe_file."""#linescontainseachlineofthefilewhichdoesn't#startwitha#andisnotempty.lines=[lineforlineinopen(probe_file).read().splitlines()iflineandnotline.startswith("#")]#listholdingeachoftheprobedirectives.probes:Dict[str,directives.Probe]={}#thisdefinesthestringonwhichtoform#theregexwhichIusetomatchthematchdirectives.match_string="".join(["match",r"(\S+)",r"(m\|.*\||m=.*=|m@.*@|m%.*%)(s?i?)",r"([pvihod]/.+/)"])match_regex=re.compile(match_string)regexes:Dict[str,Pattern]regexes={"probe":re.compile(r"Probe(TCP|UDP)(\S+)q\|(.*)\|"),"rarity":re.compile(r"rarity(\d+)"),"totalwaitms":re.compile(r"totalwaitms(\d+)"),"tcpwrappedms":re.compile(r"tcpwrappedms(\d+)"),"fallback":re.compile(r"fallback(\S+)"),"ports":re.compile(r"ports(\S+)"),"exclude":re.compile(r"ExcludeT:(\S+)")}#parsetheprobesoutfromthefileforlineinlines:#addanyportstobeexcludedtothebaseprobeclassifline.startswith("Exclude"):search=regexes["exclude"].search(line)ifsearch:#parsetheportsfromthegroupedoutputof#asearchwiththeregexdefinedabove.forprotocol,portsinparse_ports(search.group(1)).items():directives.Probe.exclude[protocol].update(ports)#newprobedirectiveifline.startswith("Probe"):#parselineintoprobeprotocol,nameandprobestringsearch=regexes["probe"].search(line)ifsearch:try:proto,name,string=search.groups()exceptValueError:print(line)raise#addthenewprobetotheendofthelistofprobesprobes[name]=directives.Probe(proto,name,string)#assigncurrent_probetothemostrecentlyaddedprobecurrent_probe=probes[name]#newmatchdirectiveelifline.startswith("match")orline.startswith("softmatch"):#servicename,matchstring,versionstringssearch=match_regex.search(line)ifsearch:#returnanyinformationmatchedbytheregexservice,regex,regex_options,version_info=search.groups()ifline[0]=="m":#newmatchobjectmatch=directives.Match(service,regex[2:-1],regex_options)#addtheversioninfotothematchobjectmatch.add_version_info(version_info)#addthematchdirectivetothecurrentprobecurrent_probe.matches.add(match)else:softmatch=directives.Softmatch(service,regex[2:-1],regex_options)current_probe.softmatches.add(softmatch)#newportsdirectiveelifline.startswith("ports"):search=regexes["ports"].search(line)ifsearch:forprotocol,portsinparse_ports(search.group(1)).items():current_probe.ports[protocol].update(ports)#newtotalwaitmsdirectiveelifline.startswith("totalwaitms"):search=regexes["totalwaitms"].search(line)ifsearch:current_probe.totalwaitms=int(search.group(1))#newraritydirectiveelifline.startswith("rarity"):search=regexes["rarity"].search(line)ifsearch:current_probe.rarity=int(search.group(1))#newfallbackdirectiveelifline.startswith("fallback"):search=regexes["fallback"].search(line)ifsearch:current_probe.fallback=set(search.group(1).split(","))returnprobesdefversion_detect_scan(target:directives.Target,probes:Dict[str,directives.Probe]):forprobeinprobes.values():probe.scan(target)if__name__=="__main__":probes=parse_probes("./small-example-probes")print(probes)exit()open_ports:DefaultDict[str,Set[int]]=defaultdict(set)open_filtered_ports:DefaultDict[str,Set[int]]=defaultdict(set)open_ports["TCP"].update([1,2,3,4])open_filtered_ports["UDP"].update([6,7,8])target=directives.Target("127.0.0.1",open_ports,open_filtered_ports)target.open_ports["TCP"].update([1,2,3])#print(target)version_detect_scan(target,probes)