\documentclass[titlepage]{article}

\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{hyperref}
\usepackage[dvipsnames]{xcolor}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{algorithm}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage[noend]{algpseudocode}

\lstset{showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\author{Sam Leonard}
\title{A Level Computer Science Non-Examined Assessment (NEA)}
\date{}

\begin{document}

\maketitle

\tableofcontents

\section{Analysis}

\subsection{Identification and Background to the Problem (Core)}

There are many situations in which exploring a network from a ``black box'' perspective
can be useful, such as a network engineer who wants to know what an outsider to the network
such as a malicious hacker might see.
This can help to secure the network against malicious threats and also in some cases detect
ports that shouldn't be listening and investigate why they are open, i.e.\ a backdoor placed
by a hacker to allow them to access a computer remotely.

\subsection{Analysis of problem (Core)}

The problem with looking at a network from the outside is that the purpose of the network is to
allow communication inside of the network, thus very little is exposed externally. This presents
a challenge as we want to know what is on the network as well as what each of them is running which
is not always possible due to the limited information that services will reveal about themselves.
Firewalls also play large part in making scanning networks difficult as sometimes they simply drop
packets instead of sending a TCP RST packet (reset connection packet). When firewalls drop packets
it becomes exponentially more difficult as you don't know whether your packet was corrupted or lost
in transit or if it was just dropped.

\subsection{Numbered List of Objectives (also called Success Criteria, the end user requirements) (Core)}

\begin{enumerate}
\item{Show a basic usage message when called with no arguments.}
\item{Show a help message when called with \texttt{--help} or \texttt{-h}.}
\item{Scan the 1000 most commonly used TCP ports when called with just an IP address.}
\item{Scan the ports specified by \texttt{-p <ports>} or \texttt{--ports <ports>}.}
\item{Parse either a comma separated list of ports e.g.\ \texttt{1,2,3,4} or a range specified set of ports e.g.
  \texttt{1{\textendash}4}}.
\item{Scan all ports in each scan type when called with \texttt{-p-}.}
\item{Don't scan the ports specified by \texttt{--exclude-ports <ports>} in any scan.}
\item{Expand a Classless Inter-Domain Routing (CIDR) specified subnet when used in the target specification.}
\item{List all of the IP addresses that would be scanned when given the \texttt{-sL} flag.}
\item{Only ping each specified address when supplied the \texttt{-sn} flag.}
\item{When doing a ping scan (\texttt{-sn}) display the Time To Live (TTL) and latency of each host.}
\item{Don't ping each of the hosts before scanning to check if they are up when supplied with the \texttt{-Pn} flag.}
\item{Perform a TCP SYN scan on the 1000 most common TCP ports on each target specified when given the \texttt{-sS} flag.}
\item{Perform a TCP \verb|Connect()| scan on the 1000 most common TCP ports on each target specified when given the \texttt{-sT} flag.}
\item{Perform a UDP scan on the 1000 most common UDP ports when on each target specified when given the \texttt{-sU} flag.}
\item{Perform version detection on the services running on each of the hosts specific when given the \texttt{-sV} flag.}
\end{enumerate}

\subsection{Description of current system or existing solutions (Core if relevant)}

Nmap is currently the most popular tool for doing port scanning and host enumeration.
It supports the following scanning types:

\begin{itemize}
\item{TCP:\ SYN}
\item{TCP:\ \verb|Connect()|}
\item{TCP:\ ACK}
\item{TCP:\ Window}
\item{TCP:\ Maimon}
\item{TCP:\ Null}
\item{TCP:\ FIN}
\item{TCP:\ Xmas}
\item{UDP}
\item{Zombie host/idle}
\item{SCTP:\ INIT}
\item{SCTP:\ COOKIE-ECHO}
\item{IP protocol scan}
\item{FTP:\ bounce scan}
\end{itemize}

As well as supporting a vast array of scanning types it also can do service version detection
and operating system detection via custom probes. Nmap also has script scanning which allows
the user to write a script specifying exactly how they want to scan e.g.\ to circumvent port
knocking (where packets must be sent to a sequence of ports in order before access to the final port is allowed).
It also supports a plethora of options to avoid firewalls or Intrusion Detection Systems (IDS) such as sending
packets with spoofed checksums/source addresses and sending decoy probes. Nmap can do many more things than I
have listed above as is illustrated quite clearly by the fact there is an entire working on using nmap
(\href{https://nmap.org/book/}{https://nmap.org/book/})

\subsection{Prospective Users (Desirable)}

The prospective users of this system would be system administrators, penetration testers or network engineers.
In my case my prospective users would be my school's system administrators and it would allow them to see an
outsiders perspective on for example the server running the school's website page or to see if any of the
programs on the servers were leaking information through banners etc. (most services send a banner with
information like what protocol version they use and other information)

\subsection{Data Dictionary (Desirable)}

\textbf{\color{red}{I looked this up and it seemed to be related to database management systems.}}

\href{https://en.wikipedia.org/wiki/Data_dictionary}{https://en.wikipedia.org/wiki/Data\_dictionary}

\subsection{Data Flow Diagram (Desirable)}

\textbf{\color{red}{This seems to be fairly relevant and to do with how data goes through my program
    i.e.\ going from the network to my port scanner into a target object and other scanners
before version detection and finally displaying to the user. Make a flowchart for this.}}

\href{https://en.wikipedia.org/wiki/Data-flow_diagram<Paste>}{https://en.wikipedia.org/wiki/Data-flow\_diagram}

\subsection{Data Sources (Desirable)}

\textbf{\color{red}{Not really sure about this.}}

\subsection{Description of Solution Details, OOP/Mobile/Networking (Core if relevant)}

To do all forms of scanning other than \verb|Connect| scanning and version detection, custom
packets are made to allow the half open (no full connection is made to the host) scanning
used in TCP SYN scanning. Making custom packets is quite difficult because the endianness
(the order the bytes are interpreted in: big endian, most significant byte first, little endian,
least significant byte first) affects how all the information packed into the packet is interpreted
by the network switch, for example the IP address 192.168.1.58 packed in big endian form but interpreted
being in little endian form comes out as 58.1.168.192 which is a completely different address and
will mean the packet is not routed to the correct host. As well as the issues with byte order
and the interpretation of information at different points the checksum which is embedded into
the packet is calculated from a psuedo-header calculated from information in the underlying
IP header and all of this has to be calculated in the right byte order (endianness).

I have used Python's multiprocessing module to allow me to spawn another process which listens
for responses from hosts and waits for a certain amount of time before returning information
on what hosts responded and in the case of ping scanning also metadata about how they responded.

In version detection scanning the relationship between the data sources and modules used is quite
complex so I have used an Object Oriented Programming (OOP) approach to group the methods
that act on the data along with the data itself. For example each probe defined in the nmap-service-probes
file can be sent to a host and matched against a list of match directives stored in the probe,
the probe class has a scan method which sends it's probe to the host and then automatically runs
match and soft-match directives against the information returned by the probe.

Parsing the match and softmatch directives was quite difficult because they include regular
expressions with special characters such as newlines and carriage returns in the form of
\verb|\n| and \verb|\r| characters which python escapes to \verb|\\n|
and \verb|\\r|. Which instead of matching a newline character and a carriage return
will match a literal backslash and then an n or an r which is not what we want. To fix this I have to substitute
newline and carriage returns back in where I find \verb|\\r| and \verb|\\r|.

\subsection{Acceptable Limitations (Supplementary)}

Originally I had planned to include dedicated operating system detection as an option
however I ran out of time having implemented version detection. However it still does
Operating system detection partially as some services are linux only and while doing
service and version detection especially the Common Platform Enumeration (CPE) parts
of the matched service/version will contain operating system information, such as
microsoft ActiveSync would indicate that the system being scanned was a windows system
which is reflected in the match directive and attached CPE information: 

\texttt{match activesync m|{\textasciicircum}.{\textbackslash}0{\textbackslash}x01{\textbackslash}0[{\textasciicircum}{\textbackslash}0]{\textbackslash}0[{\textasciicircum}{\textbackslash}0]{\textbackslash}0[{\textasciicircum}{\textbackslash}0]{\textbackslash}0[{\textasciicircum}{\textbackslash}0]{\textbackslash}0[{\textasciicircum}{\textbackslash}0]{\textbackslash}0.*{\textbackslash}0{\textbackslash}0{\textbackslash}0\$|s p/Microsoft ActiveSync/ o/Windows/ cpe:/a:microsoft:activesync/ cpe:/o:microsoft:windows/a}


\subsection{Data Volumes (Supplementary)}

\textbf{\color{red}{This seems to be about the volume of data stored in a database.}}
\href{https://stackoverflow.com/questions/5566841/what-are-data-volumes#5567390}{https://stackoverflow.com/questions/5566841/what-are-data-volumes\#5567390}

\subsection{Test Strategy (Core)}

I am going to use two different methods to test my program:
\begin{enumerate}
\item{Unit testing}
\item{Wireshark}
\end{enumerate}
I am using two separate testing strategies because they are both good at different things,
both of which I need to show that my project works. Firstly I am using unit testing to test
some general purpose functions which are pure functions (are independent of the current state
of the machine) such as \verb|ip_range()| and other functions which I can
just check the returned value against what it should be.

Wireshark is useful for the other half of the program which uses impure functions and the
low level networking e.g.\ \verb|make_tcp_packet()|. Wireshark makes this easy by allowing capture of all
the packets going over the wire, as well as this it has a vast array of packet decoders (2231 in my install)
which it can use to dissect almost any packet that would be on the network. The main
benefit of wireshark is that I can see my scanners sending packets and then check whether the parsers
that I have written for the different protocols are working. I can also check that the checksums
in each of the various protocols is valid as wireshark does checksum verification for various protocols.

\section{Design}

\subsection{Overall System Design (High Level Overview) (Core)}

There are two types of scanning implemented for different scan types in my program.
\begin{itemize}
  \item{\verb|Connect()|}
  \item{version}
  \item{listener / sender}
\end{itemize}
\verb|Connect()| scanning is the simplest in that it takes in a list of ports and simply calls the
\verb|socket.connect()| method on it and sees whether it can connect or not and the ports are
marked accordingly as open or closed.

Version scanning is very similar to \verb|Connect()| scanning in that it takes in a list of ports
and connects to them, except it then sends a probe to the target to elicit a response and gain
some information about the service running behind the port.

Listener / sender scanning does exactly what it says on the tin: it sets up a ``listener'' in another process
to listen for responses from the host which the ``sender'' is sending packets to. It can then differentiate
between open, open|filtered, filtered and closed ports based on whether it receives a packet back
and what flags (part of TCP packets are a one byte long section which store ``flags'' where each bit in the
byte represents a different flag) are set in the received packet.

\subsection{Design of User Interfaces HCI (Core)}

I have designed my system to have a similar interface to the most common tool currently used: nmap
this is because I believe that having a familiar interface will not only make it easier for someone who
is familiar with nmap to use my tool it also makes it so that anything learnt using either tool is applicable
to both which benefits everyone.

Based on this perception I have used the same option flags as nmap as well as similar help messages
and an identical call signature (how the program is used on the command line). Running 
\verb|./netscan.py <options> <target_spec>| is identical to \verb|nmap <options> <target_spec>| in terms
of which scan types will be run, which hosts will be scanned and which ports are scanned. Below you can see
the help message generated by \verb|./netscan.py --help|.
\begin{lstlisting}
usage: netscan.py [-h] [-Pn] [-sL] [-sn] [-sS] [-sT] [-sU] [-sV] [-p PORTS]
                  [--exclude_ports EXCLUDE_PORTS]
                  target_spec

positional arguments:
  target_spec           specify what to scan, i.e. 192.168.1.0/24

optional arguments:
  -h, --help            show this help message and exit
  -Pn                   assume hosts are up
  -sL                   list targets
  -sn                   disable port scanning
  -sS                   TCP SYN scan
  -sT                   TCP connect scan
  -sU                   UDP scan
  -sV                   version scan
  -p PORTS, --ports PORTS
                        scan specified ports
  --exclude_ports EXCLUDE_PORTS
                        ports to exclude from the scan
\end{lstlisting}

It shows clearly which are required arguments and which are optional ones, as well as what
each argument actually does. It also allows some some arguments to be called with either
a short format e.g.\ \verb|-p| and with a most verbose format \verb|--ports| this allows
the user to be clearer if they are using the tool as part of an automated script to perform
scanning as it is more immediately obvious what the more verbose flags do.

\subsection{Database Structure (ERD, Normalisation) (Core, if relevant)}

\textbf{\color{red}{I am fairly sure this is irrelevant to mine?}}

\subsection{System Algorithms (Flowcharts) (Core)}

\textbf{\color{Emerald}{When I have finished the first draft of the text bits I will add pictures / flowcharts}}

\subsection{Input data Validation (Core)}

My program takes very little input from the user which means that there is a very low chance of the program
crashing due to user input error as the errors are detected
All data which is entered is either parsed using a regular expression with the case of the
ports directive (\verb|-p|) or is run through checking functions like \verb|ip_utils.is_valid_ip|.
As well as using these checking functions whenever an IP address is converted between ``long form''
and ``dot form'' which is used in every type of scanning.

\subsection{Proposed Algorithms for complex structures (flow charts or Pseudo Code)}

\begin{algorithm}\label{collapse}

  \caption{My algorithm for pretty-printing a dictionary of lists of port numbers
  such that ranges are specified as start-end instead of start,start+1,\ldots,end}
  \begin{algorithmic}
    \Procedure{collapse}{}
    \State{$\textit{port\_dictionary} \gets \text{dictionary of lists of port numbers}$}
    \State{$\textit{key\_results} \gets \text{empty list}$}\Comment{stores the formatted result for each key}
    \For{$\textit{key} \in \textit{port\_dictionary}$}
      \State{$\textit{ports} \gets \text{\textit{port\_dict}[\textit{key}]}$}
      \State{$\textit{result} \gets \textit{key} + \text{``:\{''}$}
      \If{$\textit{ports} \not= \varnothing$}
        \State{$\textit{new\_sequence} \gets FALSE$}
        \For{$\textit{index} \gets 1,\text{(length of \textit{ports})}-1$}
          \State{$\textit{port} = \text{\textit{ports}[\textit{index}]}$}
          \If{$\textit{index} = 0$}
            \State{$\textit{result} \gets \textit{result} + \textit{ports}[0]$}\Comment{append the first element}
            \If{$\text{\textit{ports}[\textit{index}+1]} = \textit{port} + 1$}
            \State{$\textit{result} \gets \textit{result}+\text{``-''}$}
            \EndIf
          \EndIf
        \EndFor
      \EndIf
    \EndFor
    \EndProcedure
  \end{algorithmic}

\end{algorithm}

\subsection{Design Data Dictionary (Core)}

\section{Technical Solution}

\subsection{Program Listing}

\subsection{Comments (Core)}

\subsection{Overview to direct the examiner to areas of complexity and explain design evidence}

\section{Testing}

\subsection{Test Plan}

\subsection{Test Table / Testing Evidence (Core: lots of screenshots)}

\section{Evaluation}

\subsection{Reflection on final outcome}

\subsection{Evaluation against objectives, end user feedback}

\subsection{Potential improvements}

\section{Appendices}

You may show you program listing here

User feedback and survey data

\end{document}
