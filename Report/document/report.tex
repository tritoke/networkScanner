\documentclass[titlepage]{article}

\usepackage{appendix}
\usepackage{graphicx} % for embedding pictures
\graphicspath{ {screenshots/} }
\usepackage{wrapfig} % for use with figures
\usepackage{tikz} % for doing flow charts and stuff directly inside of latex
\usepackage{framed} % if you want a frame around a figure
\usepackage[hidelinks]{hyperref} % allows embedding links
\usepackage{url} % allows for citing websites and having the URL appear after
\usepackage[T1]{fontenc} % fixes weird font size/encoding issues
\usepackage[utf8]{inputenc} % ensures input is UTF-8
\usepackage{listings} % used to format code
\usepackage{algorithm} % used with the below package to format psuedo code
\usepackage[noend]{algpseudocode}
\usepackage{mathtools} % used for all the mathematical notation
\usepackage{etaremune} % enumerate backwards for OSI model
\usepackage{booktabs} % used for tables and making them look slick as
\usepackage{placeins} % used to ensure everything stays inside where it is 
% defined, i.e. subsections jumping above figures etc.
\usepackage[nopostdot]{glossaries} % guess what. It manages glossaries
\setacronymstyle{long-short}
\makenoidxglossaries{}

% load the glossary
\loadglsentries{glossary}

% define some colours for code
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

% code formatting options
\lstset{%
  frame=tb,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true
}


% diagramming options
\usetikzlibrary{shapes.geometric, arrows, arrows.meta, positioning}

% flow chart styles
\tikzstyle{startstop} = [
  rectangle,
  rounded corners,
  minimum width=3cm,
  minimum height=1cm,
  text centered,
  draw=black,
  inner sep=0,
  fill=red!30
]
\tikzstyle{io} = [
  trapezium,
  trapezium left angle=60,
  trapezium right angle=120,
  minimum width=3cm,
  minimum height=1cm,
  text centered,
  text width=3cm,
  inner sep=0,
  draw=black,
  trapezium stretches=true,
  fill=blue!30
]
\tikzstyle{process} = [
  rectangle,
  minimum width=3cm,
  minimum height=1cm,
  text centered,
  text width=3cm,
  inner sep=0,
  draw=black,
  fill=orange!30
]
\tikzstyle{decision} = [
  diamond,
  minimum width=3cm,
  minimum height=1cm,
  text centered,
  draw=black,
  aspect=2,
  inner sep=0,
  fill=green!30
]
\tikzstyle{arrow} = [
  thick,
  ->,
  =stealth
]

% data flow diagram styles
\tikzstyle{function} = [
  circle,
  inner sep=0pt,
  draw=black,
  minimum width=1cm,
  minimum height=1cm,
  text width=2cm,
  text centered,
  fill=red!20
]
\tikzstyle{inputoutput} = [
  rectangle,
  draw=black,
  minimum width=3cm,
  minimum height=1cm,
  text width=3cm,
  text centered,
  fill=blue!20
]
\tikzstyle{datastore} = [
  rectangle,
  inner sep=0pt,
  minimum height=1cm,
  minimum width=3cm,
  text width=3cm,
  text centered,
  fill=green!20
]
\tikzstyle{method} = [
  rectangle,
  draw=black,
  fill=gray!30,
  minimum width=2cm,
  minimum height=0.5cm,
  text centered
]

% ladder diagram lines
\tikzstyle{connecting arrow} = [-{Latex[length=2mm, width=3mm, green]}]
\tikzstyle{closing arrow} = [-{Latex[length=2mm, width=3mm, red]}]
\tikzstyle{normal arrow} = [-{Latex[length=2mm, width=3mm, blue]}]
\tikzstyle{with slope} = [above, midway, sloped]


% forces [sub]sections to contain everything that is defined before the next one
\let\Oldsection\section{}
\renewcommand{\section}{\FloatBarrier\Oldsection}

\let\Oldsubsection\subsection{}
\renewcommand{\subsection}{\FloatBarrier\Oldsubsection}

\let\Oldsubsubsection\subsubsection{}
\renewcommand{\subsubsection}{\FloatBarrier\Oldsubsubsection}


% title
\author{Sam Leonard}
\title{A Level Computer Science Non-Examined Assessment (NEA)}
\date{} % this forces no date to be shown

\begin{document}

\maketitle

\tableofcontents
\clearpage

\section{Analysis}

\subsection{Identification and Background to the Problem}

The problem I am trying to solve with my project is how to look at devices on a network from a 
``\gls{bbox}'' perspective and gain information about what \glspl{service} are running etc. Services 
are programs which their entire purpose is to provide a \textit{\gls{service}} to other programs, 
for example a server hosting a website would be running a \gls{service} whose purpose is to send the 
webpage to people who try to connect to the website. \\ 
There are many steps in-between a device turning on to interacting with the internet.

\begin{enumerate}
  \item{load networking \glspl{driver}}
  \item{Starting \gls{dhcp} \gls{daemon}}
  \item{Broadcasting \gls{dhcp} request for an \gls{ipaddr}}
  \item{Get assigned an \gls{ipaddr}}
\end{enumerate}

There are many more steps than I have listed above but these are the most important ones. Starting 
from a linux computer being switched on the first step is that the \gls{kernel} needs to load the 
networking \glspl{driver}. The \gls{kernel} is the basis for the operating system, it is what 
interacts with the hardware in the most fundamental way. \glspl{driver} are small bits of code which 
the \gls{kernel} can load in order to interact with certain hardware modules such as the \gls{nic} 
which is essential for interfacing with the network, hence the name.

Next once the \gls{kernel} has loaded the required \glspl{driver} and the system has booted the 
networking `\glspl{daemon}' must be started. In linux a \gls{daemon} is a program that runs all the 
time in the background to serve a specific purpose or utility. For example when I start my laptop 
the following \glspl{daemon} start \gls{upow} (power management), \gls{sysd} (manages the creation 
of all processes), \gls{dbus} (manages inter-process communication), iwd (manages my WiFi 
connections) and finally \gls{dhcpcd} which manages all interactions with the network around 
\gls{dhcp}.

Once the \glspl{daemon} are all started the \gls{dhcp} client can now take issue commands to the 
daemon for it to carry out. The \gls{dhcp} client is simply a daemon that runs in the background to 
carry out any interactions between the current machine and the \gls{dhcp} server. The \gls{dhcp} 
server is normally the WiFi router or network switch for the local network and it manages a list of 
which computer has which \gls{ipaddr} and negotiates with new computers trying to join a network to 
get them a free \gls{ipaddr}. The \gls{dhcp} client starts the \gls{dhcp} address negotiation with 
the server by sending a discover message with the address 255.255.255.255 which is the IP limited 
broadcast address which means that whatever is listening at the other end will forward this 
\gls{pkt} on to everyone on the \gls{subnet}. When the \gls{dhcp} \gls{server} (normally the router, 
sometimes a separate machine) on the subnet receives this message it reserves a free \gls{ipaddr} 
for that client and then responds with a \gls{dhcp} offer which contains the address the 
\gls{server} is offering, the length of time the address is valid for and the \gls{subnet} mask of 
the network. The client must then respond with a \gls{dhcp} request message to request the offered 
address, this is in case of multiple DHCP servers offering addresses. Finally the \gls{dhcp} server 
responds with a \gls{dhcp} acknowledge message showing that it has received the request. 
Figure~\ref{dhcp_negotiate} shows a \gls{pkt} capture from my laptop where I turned WiFi off, 
started wireshark listening and plugged in an Ethernet cable, I have it showing only the \gls{dhcp} 
\glspl{pkt} so that it is clear to see the entire \gls{dhcp} negotiation including the 
255.255.255.255 limited broadcast destination address and the 0.0.0.0 unassigned address in the 
source column. I mention using wireshark to do packet capturing above without explaining what either 
packet capturing or wireshark are so I will do that here. Packets I define below and wireshark is 
simply a tool which intercepts all the network communications on a single computer and records them 
to a file as well as displaying them to the user as well as performing some analysis and dissecting 
each of the protocols used. This means that I can record the \gls{dhcp} negotiation shown below and 
show it to you using wireshark to get all the information out of the packets being sent over the 
wire.
\begin{figure}[H]

  \begin{framed}

  \centering
  \begin{tikzpicture}[node distance=2cm]

    \node (nic) [process] {Network Interface Card};
    \node (router) [process, below of=nic] {router / network switch};
    \node (daemon) [process, right of=nic, xshift=2cm] {\gls{dhcp} daemon};
    \node (client) [process, right of=daemon, xshift=2cm] {\gls{dhcp} client};
    \node (server) [process, right of=router, xshift=2cm] {\gls{dhcp} server};

    \draw [arrow] (nic) -- (router);
    \draw [arrow] (router) -- (nic);
    \draw [arrow] (server) -- (router);
    \draw [arrow] (router) -- (server);
    \draw [arrow] (nic) -- (daemon);
    \draw [arrow] (daemon) -- (nic);
    \draw [arrow] (client) -- (daemon);
    \draw [arrow] (daemon) -- (client);

  \end{tikzpicture}

  \end{framed}

  \caption{%
    A block diagram showing the relationship between
    different elements of a \gls{dhcp} negotiation.
  }\label{dhcpdiagram}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{dhcp_negotiation.png}
  \caption{\gls{dhcp} address negotiation}\label{dhcp_negotiate}
\end{figure}

All computer networking is encapsulated in the \gls{osi} which has 7 layers:

\begin{etaremune}
  \item{Application: \gls{api}s, \gls{http}, \gls{ftp} among others.}
  \item{Presentation: encryption/decryption, encoding/decoding, decompression etc\ldots}
  \item{Session: Managing sessions, \gls{php} session IDs etc\ldots}
  \item{Transport: TCP and UDP among others.}
  \item{Network: ICMP and IP among others.}
  \item{Data Link: MAC addressing, Ethernet protocol etc\ldots}
  \item{Physical: The physical Ethernet cabling/\gls{nic}.}
\end{etaremune}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{osi_model.png}
  \caption{%
    OSI model diagram, source: https://www.electronicdesign.com
  }\label{osi_model}
\end{figure}
Each of these layers is essential to the running of the internet but a single communication might 
not include all of the layers. These communications are all based on the most fundamental part of 
the internet: the \gls{pkt}. Packets are sequences of ones and zeros sent between computers which 
are used to transfer data as well as to control how networks function. They consist of different 
layers of information each specifying where the \gls{pkt} where should go next at a different level 
along with fundamentally the data/instructions contained in the innermost layer. When \glspl{pkt} 
are sent between computers a certain number of layers are stripped off by each computer so that it 
knows where to send the \gls{pkt} next at which point it will add all the layers back again, this 
time with the instructions needed to go from the current computer to the next one on its route. Each 
of these layers actually consists of a number of fields at the start called a \gls{header} some 
layers also append a footer to the end of the packet. The actual data being transferred in the 
packet can be quite literally anything, \gls{http} transfers websites so \gls{html} files and images 
etc\ldots. In particular there are two pieces of information stored in headers which together define 
the final destination of the packet: the \gls{ipaddr} and the \gls{port} number. The \gls{ipaddr} 
defines the destination machine and the \gls{port} number defines which ``port'' on the remote 
machine the packet should be sent to. Ports are essential entrances to a computer, for example if a 
computer was a hotel the \gls{ipaddr} would be the address and location of the hotel and the 
\gls{port} number would be the room inside the hotel. There are 65535 \glspl{port} and 0 is a 
special reserved port. Both \gls{tcp} and \gls{udp} use \glspl{port}, \gls{tcp} \glspl{port} are 
mainly used for transferring data where reliability is a concern, as \gls{tcp} has built in checks 
for packet loss whereas \gls{udp} does not and as such is used for purposes where speed is more 
important and missing some data is inconsequential, such as video streaming and playing games. 

I'm going to use the example of getting a very simple static HTML page with an image inside. The 
code for the page is shown in listing~\ref{examplepage}. In figure~\ref{basicwebpage} you can see 
how the page renders. However far more interestingly is how the browser retrieved the page, in 
figure~\ref{getrequest} you can see the full sequence of \glspl{pkt} that were exchanged for the 
browser to get the resources it needed to render the page. I am hosting the page using Python3's 
http.server module which is super convenient and just makes the current directory open on port 8000 
from there I can just navigate to /example.html and it will render the page. Breaking 
figure~\ref{getrequest} down \gls{pkt} one shows the browser receiving the request from the user to 
display \verb|http://192.168.1.47:8000/example.html| and attempting to connect to 192.168.1.47 on 
port 8000. Packets two and three show the negotiation of this request through to the full connection 
being made. The browser now makes an \gls{http} GET request for the page example.html over the 
established TCP connection as shown in \gls{pkt} 4. The server then acknowledges the request and 
sends a \gls{pkt} with the PSH flag set as shown in \glspl{pkt} 6 and 7. The PSH flag is a request 
to the browser to say that it is OK to received the buffered data, i.e.\ example.html. The browser 
then sends back an acknowledgement and the server sends the page as shown in \glspl{pkt} 7 and 8. 
Finally the browser sends a final acknowledgement of having received the page before initiating a 
graceful session teardown by sending a FIN ACK \gls{pkt} which indicates the end of a session. Once 
the server responds to the FIN ACK with it's own the browser sends a final acknowledgement. This 
then repeats itself when the browser parses the HTML and realises theres an image which it needs to 
get from the server as well, except the image is a larger file and so takes a few more PSH 
\glspl{pkt}. In figures~\ref{getrequestladder} and~\ref{ladder} you can see a set of ladder diagrams
which show the entire transaction symbolically. I have also colour coded figure~\ref{ladder} with
green arrow heads to the initial handshakes, blue for the HTTP protocol transactions and red for
the TCP connection teardown packets.

This shows clearly the interaction between each of the different layers in the OSI model,
the browser at level 7: Application rendering the webpage. Level 6: Presentation is skipped as
we have no files which need to be served compressed because they are so large. Level 5: Session
is shown by the TCP session negotiation and graceful teardown of the TCP session. Level 4: Transport
is shown when the image and webpage are transferred from the server to the browser. Level 3/2/1
are shown in figure~\ref{deconstructed} where you can see the IP layer information along with
Ethernet II and finally frame 4 which is the bytes that went down the wire.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{basic_webpage.png}
  \caption{%
    A basic static \gls{html} webpage.
  }\label{basicwebpage}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{website_get.png}
  \caption{%
    A full chain of \glspl{pkt} that shows retrieving a basic webpage
    from the server.
  }\label{getrequest}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{website_get_ladder.png}
  \caption{%
    Ladder diagram of figure~\ref{getrequest}.
  }\label{getrequestladder}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{framed}
  \begin{tikzpicture}
    \node[rectangle,minimum width=.8\textwidth,minimum height=.8\textheight] (ladder) {};
      \draw[black,very thick] (ladder.north west) -- (ladder.south west);
      \draw[black,very thick] (ladder.north east) -- (ladder.south east);
    \node[above of=ladder, xshift=-4.5cm,yshift=7cm] (local 0) {local machine};
    \node[above of=ladder, xshift=4.5cm, yshift=7cm] (web 0) {webserver};
    \foreach \i [count=\j from 0]in {1,...,14}{
      \node [below=0.85cm of local \j] (local \i) {};
      \node [below=0.85cm of web \j] (web \i) {};
    }

    \draw[connecting arrow] (local 0) -- node[with slope] {SYN} (web 1);
    \draw[connecting arrow]   (web 1) -- node[with slope] {SYN, ACK} (local 2);
    \draw[connecting arrow] (local 2) -- node[with slope] {ACK} (web 3);
    \draw[normal arrow]     (local 3) -- node[with slope] {HTTP GET /example.html} (web 4);
    \draw[normal arrow]       (web 4) -- node[with slope] {HTTP 200 OK} (local 5);
    \draw[closing arrow]    (local 5) -- node[with slope] {FIN, ACK} (web 6);
    \draw[closing arrow]      (web 6) -- node[with slope] {ACK} (local 7);
    \draw[connecting arrow] (local 7) -- node[with slope] {SYN} (web 8);
    \draw[connecting arrow]   (web 8) -- node[with slope] {SYN, ACK} (local 9);
    \draw[connecting arrow] (local 9) -- node[with slope] {ACK} (web 10);
    \draw[normal arrow]    (local 10) -- node[with slope] {HTTP GET /document/screenshots/packet\_drop.png} (web 11);
    \draw[normal arrow]      (web 11) -- node[with slope] {HTTP 200 OK} (local 12);
    \draw[closing arrow]   (local 12) -- node[with slope] {FIN, ACK} (web 13);
    \draw[closing arrow]     (web 13) -- node[with slope] {ACK} (local 14);

  \end{tikzpicture}
  \end{framed}
  \caption{%
    A simplified ladder diagram showing the transaction in figure~\ref{getrequest}
  }\label{ladder}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{deconstructed_packet.png}
  \caption{%
    A look inside a TCP \gls{pkt}.
  }\label{deconstructed}
\end{figure}

\lstset{language=HTML}
\lstinputlisting[caption={example.html}, label={examplepage}]{../example.html}

\subsection{Analysis of problem}

The problem with looking at a network from the outside is that the purpose of the network is to 
allow communication inside of the network, thus very little is exposed externally. This presents a 
challenge as we want to know what is on the network as well as what each of them is running which is 
not always possible due to the limited information that \glspl{service} will reveal about 
themselves. Firewalls also play large part in making scanning networks difficult as sometimes they 
simply drop \glspl{pkt} instead of sending a \gls{tcp} RST \gls{pkt} (reset connection \gls{pkt}). 
When firewalls drop \glspl{pkt} it becomes exponentially more difficult as you don't know whether 
your \gls{pkt} was corrupted or lost in transit or if it was just dropped.
Dropping a packet means that when a packet is received no response is sent back
as if the connection was just ``dropped''. \\\\ To demonstrate this 
I will show three things:

\begin{enumerate}
  \item{A successful connection over \gls{tcp}.}
  \item{An attempted connection to a closed port.}
  \item{An attempted connection with a firewall rule to drop packets.}
\end{enumerate}

Firstly A successful \gls{tcp} connection. For a \gls{tcp} connection to be established there is a 
three way handshake between the communicating machines. Firstly the machine trying to establish the 
connection sends a \gls{tcp} SYN packet to the other machine, this packet holds a dual purpose, to 
ask for a connection and if it is accepted to SYNchronise the sequence numbers being used to detect 
whether packets have been lost in transport. The receiving machine then replies with a \gls{tcp} SYN 
ACK which confirms the starting sequence number with the SYN part and ACKnowledges the connection 
request. The sending machine then acknowledges this by sending a final \gls{tcp} ACK packet back. 
This connection initialisation is shown in figure~\ref{data_transfer} by packets one, two and three. 
Data transfer can then commence by sending a \gls{tcp} packet with the PSH and ACK flags set along 
with the data in the data portion of the packet, this is shown in figure~\ref{data} where wireshark 
allows us to take a look inside the packet to see the data being sent in the packet along with the 
PSH and ACK flags being set. The code I used to generate these is shown in figures~\ref{sender} 
and~\ref{receiver}. Breaking the code down in figure~\ref{receiver} you can see me initialising a 
socket object then I bind it to localhost (127.0.0.1) port 12345 localhost is just an address which 
allows connections between programs running on the same computer as connections are looped back onto 
the current machine, hence its alternative name: the loopback address. I then tell it to listen for 
incoming connections, the one just means how many connections to keep as a backlog. I then accept 
the connection from the program in figure~\ref{sender}, line 3. I then tell the program to listen 
for up to 1024 bytes in the data part of any TCP packets sent. The program in figure~\ref{sender} 
then sends some data which we then see printed to the screen in figure~\ref{receiver}, both programs 
then close the connection.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{data_transfer.png}
  \caption{%
    Packets starting a TCP session, transferring some data then ending it.
  }\label{data_transfer}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{sender.png}
  \caption{%
    Transferring some basic text data over a TCP connection.
  }\label{sender}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{receiver.png}
  \caption{%
    Receiving some basic text data over a TCP connection.
  }\label{receiver}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{data.png}
  \caption{%
    Highlighted packet carrying the data being transferred in figure~\ref{sender}.
  }\label{data}
\end{figure}

Next an attempted connection to a closed port. In figure~\ref{firewall} packet one you can see
the same \gls{tcp} SYN packet as we saw in the attempted connection to an open port, as you
would expect. The difference comes in the next packet with the \gls{tcp} RST flag being sent
back. This flag means to reset the connection, or if the connection is not yet established
as in this case it means that the port is closed, hence why the packet is highlighted red
in figure~\ref{firewall}. The code used to generate this is shown in figure~\ref{firewall_code}
line two shows the initialisation of a socket object. In line 3 the program tries to connect
to port 12345 on localhost again, except this time we get a connection refused error back
this shows us that the remote host sent a \gls{tcp} RST packet back, which is reflected in
figure~\ref{firewall}.

Finally I will show a connection where the firewall is configured to drop the packet. However first 
I will explain a bit about firewalls and how they work. Firewalls are essentially the gatekeepers of 
the internet they decide whether a packet gets to pass or whether they shall not pass. Firewalls 
work by a set of rules which decide what happens to it. A rule might be that it is coming from a 
certain \gls{ipaddr} or has a certain destination port. The actions taken after the packet has had 
it's fate decided by the rules can be one of the following three (on iptables on linux): ACCEPT, 
DROP and RETURN, accept does exactly what you think it would an lets the packet through, drop quite 
literally just drops the packet and sends no reply whatsoever, return is more complicated and has no 
effect on how port scanning is done and as such we will ignore it. A common set of rules for 
something like a webserver would be to DROP all incoming packets and then allow exceptions for 
certain ports i.e.\ port 80 for \gls{http} or 443 for \gls{https}. I will be using a linux utility 
called iptables for implementing all firewall rules on my system for demonstration purposes. Packet 
number three in figure~\ref{firewall} shows the connection request from line 4 
of~\ref{firewall_code} except that I have enabled a firewall rule to drop all \glspl{pkt} from the 
address 127.0.0.1, using the iptables command as so: \verb$iptables -I INPUT -s 127.0.0.1 -j DROP$. 
This command reads as for all \glspl{pkt} arriving (\verb|-I INPUT|) with source address 127.0.0.1 
(\verb|-s 127.0.0.1|) drop them sending no response (\verb|-j DROP|). With this firewall rule in 
place you can see in figure~\ref{firewall} \gls{pkt} 3 receives no response and as such Python 
assumes that the \gls{pkt} just got lost and as such tries to send the \gls{pkt} again repeatedly, 
this continued for more than 30 seconds before a stopped it as shown by the time column in 
figure~\ref{firewall} and the final \verb|KeyboardInterrupt| in figure~\ref{firewall_code}. The 
amount of time that a system will wait still trying to reconnect depends on the OS and a other 
factors but the minimum time is 100 seconds as specified by RFC 1122, on most systems it will be 
between 13 and 30 minutes according the linux manual page on \gls{tcp}.

\begin{verbatim}
man 7 tcp:
tcp_retries2 (integer; default: 15; since Linux 2.2)
  The maximum number of times a TCP packet is retransmitted in
  established state before giving up. The default value is 15,
  which corresponds to a duration of approximately between 13 to 30
  minutes, depending on the retransmission timeout. The RFC 1122
  specified minimum limit of 100 seconds is typically deemed too short.
\end{verbatim}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{packet_drop.png}
  \caption{%
    Attempted connection to a closed port with and without firewall rule to drop \glspl{pkt}.
  }\label{firewall}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{packet_drop_code.png}
  \caption{%
    The code used to produce firewall \gls{pkt} dropping example in figure~\ref{firewall}
  }\label{firewall_code}
\end{figure}

Having explained firewalls, how they affect port scanning and other things above I will now explain 
what I am actually trying to achieve with my project and how I am going to do it. I am trying to 
make a tool similar to nmap which will be able to detect the state (as in whether the port is 
open/closed or filtered etc) of ports on remote machines, detect which hosts are up on a subnet and 
finally I want to be able to try to detect what services are listening behind any of the ports. I am 
going to be writing in Python version 3.7.2 as it is the latest stable release of Python 3 and has 
many features which are not in even fairly recent versions such as 3.5, the biggest one of these 
being fstrings which are where I can put a single a `f' before a string and then any formatting 
options I put inside using curly braces are expanded and formatted accordingly. This allows for a 
clear and consistent string formatting syntax which I will use extensively. I will be using Python 
in particular as a language because it is very readable and has extensive low level bindings to C 
networking functions with the socket module allowing me to write code quickly which is easily 
understandable and has a clear purpose and at the same time be able to use low level networking 
functions and even changing the behaviour at this low level with \verb|socket.setsockopt|. As well 
as this the socket module allows me to open sockets that communicate using many different protocols 
such as \gls{tcp}, \gls{udp} and \gls{icmp} just to name a few. These features combine to make 
Python a great language for writing networking software with a high level of abstraction. In regards 
to the OSI model my code will sit with the user interface at level 7 specifying what to do at a high 
level then the actual scanning takes place at levels 3, 4 and 5 with host detection being at level 
3. Port scanning will be taking place At level 4 for \gls{tcp} SYN scanning and \gls{udp} scanning. 
Whereas \verb|connect()| scanning and version detection will sit at level 5. Finally I will look at 
what is actually handling all of the networking on my machine. My machine runs linux and as such all 
networking is handled by system calls to the linux kernel. For example the \verb|socket.connect| 
method is just a call to the underlying linux kernel's connect syscall but presenting a kinder call 
signature to the user as the Python socket library does some processing before the syscall is made. 

\subsection{Success Criteria}

\begin{enumerate}

  \item{%
    Probe another computer's networking from a \gls{bbox} perspective.
  }\label{blackbox}
  \item{%
    To help the user with usage/help messages when prompted.  
  }\label{usage}
  \item{%
    Translate \gls{cidr} specified subnets into a list of domains.
  }\label{cidr}
  \item{%
    Send \gls{icmp} ECHO requests to determine whether a machine is active
    or not.
  }\label{ping}
  \item{%
    Perform any scan type without first checking whether the host is up.
  }\label{nocheck}
  \item{%
    Detect whether a TCP port is open (can be connected to).
  }\label{tcpopen}
  \item{%
    Detect whether a TCP port is closed (will refuse connections).
  }\label{tcpclosed}
  \item{%
    Detect whether a TCP port is filtered (a firewall is
    preventing or monitoring access).
  }\label{tcpfiltered}
  \item{%
    Detect whether a UDP port is open (can be connected to).
  }\label{udpopen}
  \item{%
    Detect whether a UDP port is closed (will refuse connections).
  }\label{udpclosed}
  \item{%
    Detect whether a UDP port is filtered (a firewall is
    preventing or monitoring access).
  }\label{udpfiltered}
  \item{%
    Detect the operating system of another machine on the network
    solely from sending packets to the machine and interpreting the responses.
  }\label{osdetect}
  \item{%
    Detect what service is listening behind a port.
  }\label{servicedetect}
  \item{%
    Detect the version of the service running behind a port.
  }\label{versiondetect}

\end{enumerate}

\subsection{Description of current system or existing solutions}

Nmap is currently the most popular tool for doing \gls{port} scanning and host enumeration.
It supports the scanning types for determining information about remote hosts.

\begin{itemize}
  \item{\gls{tcp}:\ SYN}
  \item{\gls{tcp}:\ \verb|Connect()|}
  \item{\gls{tcp}:\ ACK}
  \item{\gls{tcp}:\ Window}
  \item{\gls{tcp}:\ Maimon}
  \item{\gls{tcp}:\ Null}
  \item{\gls{tcp}:\ FIN}
  \item{\gls{tcp}:\ Xmas}
  \item{\gls{udp}}
  \item{Zombie host/idle}
  \item{\gls{sctp}:\ INIT}
  \item{\gls{sctp}:\ COOKIE-ECHO}
  \item{IP protocol scan}
  \item{\gls{ftp}:\ bounce scan}
\end{itemize}

As well as supporting a vast array of scanning types it also can do \gls{service} version detection 
and operating system detection via custom probes. Nmap also has script scanning which allows the 
user to write a script specifying exactly how they want to scan e.g.\ to circumvent \gls{port 
knocking} (where \glspl{pkt} must be sent to a sequence of \glspl{port} in order before access to 
the final\gls{port}is allowed). It also supports a plethora of options to avoid firewalls or 
\gls{ids} such as sending \glspl{pkt} with spoofed \glspl{csum}/source addresses and sending decoy 
probes. Nmap can do many more things than I have listed above as is illustrated quite clearly by the
fact there is an entire working on using nmap (\href{https://nmap.org/book/}{https://nmap.org/book/}).
The following is an example nmap scan
which I did on my home network: \verb|nmap -sC -sV -oA networkscan 192.168.1.0/24|. Breaking
it down this means to enable script scanning \verb|-sc|, enable version detection \verb|-sV|
and then output all results in all the common formats: XML, nmap and greppable, using the
base name \verb|networkscan| which produces three files: \verb|networkscan.(nmap,gnmap,xml)|.
Before I go into what each file contains I will explain some terminology, greppable is anything
which can be easily searched with the linux \verb|grep| which stands for Globally search a Regular
Expression and Print, which basically means look in files for lines that contain a certain word
or pattern, for example finding all lines with the word ``hi'' in them in the file ``document''
\verb|grep hi document|. Onto the files: \verb|networkscan.nmap| contains what would usually
be printed by nmap while the scan is being run, it looks like this:
\begin{verbatim}
# Nmap 7.70 scan initiated Wed Apr 10 19:36:18 2019 as:
    nmap -sC -sV -oA /home/tritoke/thing 192.168.1.0/24
Nmap scan report for router.asus.com (192.168.1.1)
Host is up (1.0s latency).
Not shown: 995 closed ports
PORT     STATE SERVICE    VERSION
53/tcp   open  domain     (generic dns response: NOTIMP)
| fingerprint-strings: 
|   DNSVersionBindReqTCP: 
|     version
|_    bind
80/tcp   open  http       ASUS WRT http admin
|_http-server-header: httpd/2.0
|_http-title: Site doesn't have a title (text/html).
515/tcp  open  printer
8443/tcp open  ssl/http   ASUS WRT http admin
|_http-server-header: httpd/2.0
|_http-title: Site doesn't have a title (text/html).
| ssl-cert: Subject: commonName=192.168.1.1/countryName=US
| Not valid before: 2018-05-05T05:05:17
|_Not valid after:  2028-05-05T05:05:17
9100/tcp open  jetdirect?
1 service unrecognized despite returning data. If you know the service/version,
please submit the following fingerprint at
https://nmap.org/cgi-bin/submit.cgi?new-service :
SF-Port53-TCP:V=7.70%I=7%D=4/10%Time=5CAE3DC5%P=x86_64-pc-linux-gnu%r(DNSV
SF:ersionBindReqTCP,20,"\0\x1e\0\x06\x85\x85\0\x01\0\0\0\0\0\0\x07version\
SF:x04bind\0\0\x10\0\x03")%r(DNSStatusRequestTCP,E,"\0\x0c\0\0\x90\x04\0\0
SF:\0\0\0\0\0\0");
Service Info: CPE: cpe:/o:asus:wrt_firmware
\end{verbatim}
Above is just the report for one such device in the report as the full thing is over 200 lines lone.
In it you can see information such as which ports are open and what services are running behind them
as this is my router you can see port 8443 which nmap has recognised to be hosting the ASUS web
admin from which you can configure the route. Then after than some other associated information
extracted from the server. Most of this extra information is from the \verb|-sC| flag which is
script scanning and allows advanced interaction with running services specifically to gain more
information by providing specialised probing per protocol. We can also see at the end an
unrecognised service which nmap shows us the data it returned and asks us to submit a new service
report at a given URL if we recognise the service. This system of submitting fingerprints of
services is how nmap is so good at recognising services: it has a lot of data to look at and learn
from in regards to service fingerprinting.

Next \verb|networkscan.gnmap|:
\begin{verbatim}
# Nmap 7.70 scan initiated Wed Apr 10 19:36:18 2019 as:
    nmap -sC -sV -oA /home/tritoke/networkscan 192.168.1.0/24
Host: 192.168.1.1 (router.asus.com) Status: Up
Host: 192.168.1.1 (router.asus.com) Ports: 53/open/tcp//domain//
      (generic dns response: NOTIMP)/, 80/open/tcp//http//ASUS WRT http admin/,
      515/open/tcp//printer///, 8443/open/tcp//ssl|http//ASUS WRT http admin/,
      9100/open/tcp//jetdirect?///  Ignored State: closed (995)
Host: 192.168.1.8 (android-25a97e36c2e74456)  Status: Up
Host: 192.168.1.8 (android-25a97e36c2e74456)  Ports: 5060/filtered/tcp//sip///
      Ignored State: closed (999)
\end{verbatim}
Again this is not all of the file as it is very large. As you can see above all of the information 
is on a single line for each type of scan, this is useful if you want to scan a large number of 
hosts and just want to know which hosts are up you can do \verb|grep 'Status: Up' networkscan.gnmap|
which outputs this:
\begin{verbatim}
$ grep 'Status: Up' networkscan.gnmap
Host: 192.168.1.1 (router.asus.com) Status: Up
Host: 192.168.1.8 (android-25a97e36c2e74456) Status: Up
Host: 192.168.1.10 (diskstation) Status: Up
Host: 192.168.1.88 () Status: Up
Host: 192.168.1.88 () Status: Up
Host: 192.168.1.117 () Status: Up
Host: 192.168.1.159 (groot) Status: Up
Host: 192.168.1.159 (groot) Status: Up
Host: 192.168.1.176 (ET0021B7C01F2E) Status: Up
\end{verbatim}
Showing you clearly the hosts which are online and then their host names. Other ways to use this
output format would be to find out which ports are open on only one machine, or which hosts have a
webserver running on them or a vulnerable version of a mail server etc. In general it is useful for
when you want to filter results.

Finally we have \gls{xml} format:
\lstset{language=xml}
\begin{lstlisting}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE nmaprun>
<?xml-stylesheet href="file:///usr/bin/../share/nmap/nmap.xsl" type="text/xsl"?>
<!-- Nmap 7.70 scan initiated Wed Apr 10 19:36:18 2019 as: nmap -sC -sV -oA /home/tritoke/thing 192.168.1.0/24 -->
<nmaprun scanner="nmap" args="nmap -sC -sV -oA /home/tritoke/thing 192.168.1.0/24" start="1554921378" startstr="Wed Apr 10 19:36:18 2019" version="7.70" xmloutputversion="1.04">
<verbose level="0"/>
<debugging level="0"/>
<host starttime="1554921379" endtime="1554923187"><status state="up" reason="syn-ack" reason_ttl="0"/>
<address addr="192.168.1.1" addrtype="ipv4"/>
<hostnames>
<hostname name="router.asus.com" type="PTR"/>
</hostnames>
<ports><extraports state="closed" count="995">
<extrareasons reason="conn-refused" count="995"/>
</extraports>
<port protocol="tcp" portid="53"><state state="open" reason="syn-ack" reason_ttl="0"/><service name="domain" extrainfo="generic dns response: NOTIMP" servicefp="SF-Port53-TCP:V=7.70%I=7%D=4/10%Time=5CAE3DC5%P=x86_64
-pc-linux-gnu%r(DNSVersionBindReqTCP,20,&quot;\0\x1e\0\x06\x85\x85\0
\x01\0\0\0\0\0\0\x07version\x04bind\0\0\x10\0\x03&quot;)%r
(DNSStatusRequestTCP,E,&quot;\0\x0c\0\0\x90\x04\0\0\0\0\0\0\0\0&quot;);" method="probed" conf="10"/><script id="fingerprint-strings" output="&#xa;  DNSVersionBindReqTCP: &#xa;    version&#xa;    bind"><elem key="DNSVersionBindReqTCP">&#xa;    version&#xa;    bind</elem>
</script></port>
\end{lstlisting}
It is verbose in the extreme contains the reason why each port has the state it does as well as a
vast amount of other data that the other scans didn't include as well as this it is not very human
readable meaning that this format is more likely available because it is easier for other programs
to parse than the other formats. As well as this the verbosity can be good if you really need to
dive into why a port was marked as closed etc or the exact bytes that a service replied with.

In terms of where nmap lives in the software stack is that it is an application at level 7 when the
user interacts with it but it uses several libraries which interact at level 2 which it uses to get
the raw headers of the packets being sent and thus gain information from them.
Nmap has virtually no competitors other than possibly Angry IP Scanner which
is another open source network scanner expect it has a much smaller user base.

\begin{figure}[H]

  \begin{framed}

  \centering
  \begin{tikzpicture}[node distance=2cm]

    \node (user) [process] {User};
    \node (nmap) [process, right of=user, xshift=2cm] {nmap};
    \node (nic) [process, right of=nmap, xshift=2cm] {Network Interface Card};
    \node (router) [process, below of=nic] {router / network switch};
    \node (target) [process, below of=router] {target server};
    \node (dnsserver) [process, left of=target, xshift=-2cm] {\gls{dns} client};

    \draw [arrow] (nic) -- (router);
    \draw [arrow] (router) -- (nic);
    \draw [arrow] (target) -- (router);
    \draw [arrow] (router) -- (target);
    \draw [arrow] (dnsserver) |- (router);
    \draw [arrow] (router) -| (dnsserver);
    \draw [arrow] (nic) -- (nmap);
    \draw [arrow] (nmap) -- (nic);
    \draw [arrow] (user) -- (nmap);
    \draw [arrow] (nmap) -- (user);

  \end{tikzpicture}

  \end{framed}

  \caption{%
    A block diagram showing how nmap sits in the software stack.
  }\label{nmapblock}

\end{figure}

\begin{figure}[H]
  \hspace{2cm}
  \begin{framed}

  \centering
  \begin{tikzpicture}[node distance=2cm]

    \node (start) [startstop] {start nmap};
    \node (get) [io, below of=start] {get user input};
    \node (arguments) [process, below of=get] {parse the arguments};
    \node (host) [process, below of=arguments] {begin scanning host};
    \node (probe) [process, right of=host, xshift=2cm] {send probe};
    \node (response) [process, below of=probe] {receive and interpret probe};
    \node (probes) [decision, below of=response, yshift=-0.5cm] {more probes to send?};
    \node (hosts) [decision, left of=probes, below of=probes, xshift=-2cm, yshift=-0.5cm] {more hosts to scan?};
    \node (report) [io, below of=hosts, yshift=-0.5cm] {report results};
    \node (end) [startstop, below of=report] {end scan};

    \draw [arrow] (start) -- (get);
    \draw [arrow] (get) -- (arguments);
    \draw [arrow] (arguments) -- (host);
    \draw [arrow] (host) -- (probe);
    \draw [arrow] (probe) -- (response);
    \draw [arrow] (response) -- (probes);
    \draw [arrow] (probes) -- ([xshift=1cm]probes.east) node[anchor=east,yshift=2.25cm] {yes} |- (probe.east);
    \draw [arrow] (probes) -| node[anchor=south,xshift=0.8cm] {no} (hosts);
    \draw [arrow] (hosts) -- ([xshift=-1cm]hosts.west) node[anchor=east,yshift=3.5cm] {no} |- (host);
    \draw [arrow] (hosts) node[anchor=east,yshift=-1.5cm] {yes} -- (report);
    \draw [arrow] (report) -- (end);

  \end{tikzpicture}

  \end{framed}

  \caption{%
    A flow chart showing how nmap does scanning.
  }\label{nmapflow}

\end{figure}

\subsection{Prospective Users}

The prospective users of this system would be system administrators, penetration testers or network
engineers. In my case my prospective users would be my school's system administrators and it would 
allow them to see an outsiders perspective on for example the \gls{server} running the school's 
website page or to see if any of the programs on the \glspl{server} were leaking information
through \glspl{banner} etc. (most \glspl{service} send a \gls{banner} with information like what
protocol version they use and other information).
Banners are short strings of text which a service or program will send to identify itself when
it receives a new connection. They often contain information such as protocol version etc, which
allows the connecting client to know how to communicate with the service. However they can also
reveal too much information such as the version number of the service running, if the service
version is old then it is likely that bugs will have been found in the program since then
this information could allow an attacker to gain access to the server by exploiting the vulnerability
in that service. This can obviously be prevented by keeping services up to date, however that
is not always possible so as a best practice banners should reveal the minimum amount of information
possible such that the client can interact with the service.

\subsection{Data Dictionary}

So while my program is running it will need to store many different things in memory:
\begin{itemize}
  \item{the list of hosts to scan}
  \item{the list of ports to scan on each host}
  \item{the state of each port we are scanning on each host}
  \item{the packet received by the listening socket (temporarily before processing)}
  \item{various counters and positional indicators are almost inevitable}
  \item{the probes to be used for version detection}
\end{itemize}
So I am going to try to estimate the amount of RAM my program will use based on scanning a 
\gls{cidr} specified subnet of 192.168.1.0/24, and the most common ports 1000 ports of each machine
I will not consider version detection as I am unsure of how I will implement it currently.
To measure the size of object in python we can use the \verb|getsizeof| function provided by the
\verb|sys| module, I also have a file called `hosts' which contains the addresses specified by
192.168.1.0/24 and a file `ping\_bytes' which contains 4 captured packets from the ping command
which I captured during an early exploratory testing phase.
\lstset{language=python}
\begin{lstlisting}[label=testingsize,caption=some testing I did on the size of python objects]
>>> with open("hosts", "r") as f:
...     hosts = f.read().splitlines()
... 
>>> import sys
>>> sys.getsizeof(hosts)
2216
>>> ports = list(range(1000))
>>> sys.getsizeof(ports)
9112
>>> len(hosts)*sys.getsizeof(ports) / 2**10  # 2*10 is one kibibyte
2278.0
>>> sys.getsizeof(True)
28
>>> len(hosts)*(sys.getsizeof(True)) / 2**10
7.0
>>> pings[0]
'45 00 00 54 0f 82 40 00 40 01 2d 25 7f 00 00 01 7f 00 00 01 08 00 41 c5 02 4f 00 01 cd ef 0f 5c de 9b 0d 00 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37'
>>> from binascii import unhexlify
>>> ping = unhexlify(pings[0].replace(" ", ""))  # turn the string of numbers into a bytes object
>>> sys.getsizeof(ping)
117
>>> len(hosts)*sys.getsizeof(ping) / 2**10
29.25
>>> 2278.0 + 7.0 + 29.25 + 2.22
2316.47
\end{lstlisting}
As shown in Listing~\ref{testingsize} we can see that by far the most space intensive item stored
by our program will be the port numbers for each host, making up just less that ninety six percent
of the total space used by the mock data I created. However overall 2.3 mebibytes is not a huge
amount of data by any means.

\begin{center}
  \begin{tabular}{p{3cm} l r r}
    \toprule
    Holding    & Data type   & Space used /Kib & Percentage of total \\
    \midrule
    ports      & List[int]   & 2278            & 98.34 \\
    hosts      & List[str]   & 2.22            & 0.1   \\
    port state & List[bool]  & 7               & 0.3   \\
    packets    & List[bytes] & 29.25           & 1.26  \\
    \bottomrule
  \end{tabular}
\end{center}

\subsection{Data Flow Diagram}

In my application there will be three way information flow: 
\begin{enumerate}
  \item{sending packets (data) out from my application}
  \item{receiving packets back from the targets}
  \item{how my program sends data around between functions}
\end{enumerate}

\begin{figure}[H]
  \centering
  \begin{framed}
  \begin{tikzpicture}[node distance=2cm]
    % \node [function] (no) {hi};
    % \node [inputoutput, below of=no] (beans) {for you};
    \node [inputoutput] (input) {Get User Input};
    \node [function, below of=input, yshift=-0.5cm] (hosts) {Generate List of Hosts and Ports to Scan};
    \node [function, below of=hosts, yshift=-1cm] (listen) {Start Listener};
    \node [function, below of=listen, yshift=-1cm] (create) {Create the \gls{tcp} / \gls{udp} / \gls{icmp} Probes};
    \node [inputoutput, below of=create, yshift=-0.5cm] (send) {Send the Probes to the Hosts Specified};
    \node [function, below of=send,yshift=-0.3cm] (stop) {Stop Listener};
    \node [datastore, right of=stop, xshift=2cm, yshift=2.3cm] (responses) {Receive and Store the Responses};
      \draw [black,very thick] (responses.north west) -- (responses.north east);
      \draw [black,very thick] (responses.south west) -- (responses.south east);
    \node [function, below of=stop, yshift=-1cm] (return) {Return the Information About Each Host};
    \node [inputoutput, right of=return, xshift=2cm] (finish) {Output Information to User};
    \node [method,left of=listen, xshift=-1.5cm] {\verb|socket.accept|};
    \node [method,left of=create, xshift=-1.5cm, text width=2.6cm] {\verb|struct.pack| \verb|socket.connect|};
    \node [method,left of=send, xshift=-1.5cm] {\verb|socket.sendto|};
    \node [method,left of=stop, xshift=-1.5cm] {\verb|socket.close|};
    \node [method,right of=responses,yshift=1.2cm,xshift=-0.62cm,text width=2.4cm] {\verb|socket.recv| \verb|struct.unpack|};

    \path[arrow]{
      (input) edge node [right] {} (hosts)
      (hosts) edge node [right] {} (listen)
      (listen) edge node [right] {} (create)
      (create) edge node [right] {} (send)
      (send) edge node [right] {} (stop)
      (listen) edge[bend left] node [left] {} (responses)
      (responses) edge[bend left] node [left] {} (stop)
      (stop) edge node [right] {} (return)
      (return) edge node[bend right] [right] {} (finish)
    };
  \end{tikzpicture}
  \end{framed}
  \caption{%
    A data flow digram for information in my application.
  }\label{dataflow}
\end{figure}

\subsection{Description of Solution Details}

I will be using Python version 3.7.2 for my project because I am already familiar with Python's
syntax and it's socket library has a very nice high level \gls{api} for making system calls to
the kernel's low level networking functions. This makes it very nice for a networking project
like mine as it allows me to easily prototype and explore many ideas about how I could implement
my solution without wasting vast amounts of time.

The first point of the success criteria that I wanted to get a feel for was receiving and sending
\gls{icmp} ECHO requests aka pings. \gls{icmp} as a protocol sits at layer 3 of the \gls{osi}
this means it is a layer below what you are normally give access to in the socket module. This
means instead of getting a bytes object with just the data from the header you instead get a bytes
object which contains the entire packet and you have to dissect it yourself to get the information
out of it, this can be quite difficult if it weren't for the struct module. The struct module 
provides a convenient API for converting between packed values i.e.\ packets in network endianness
to unpacked values i.e.\ a double representing the current time in local endianness. Interactions
with the socket module are mainly through the pack and unpack functions. For each of these
functions you provide a format specifier defining how to unpack/pack the bytes/values. 
In Listing~\ref{echosend} you can see an example of me using the struct.pack function to pack
the values which comprise an \gls{icmp} ECHO REQUEST into a packet and sending it the localhost
address (127.0.0.1). This program is effectively the complement to the program listed in
listing~\ref{echorecv} which uses struct.unpack to unpack value from the received \gls{icmp}
packet before printing the fields out to the terminal. Listing~\ref{echosend} makes use of the
IP checksum function which I wrote. In figure~\ref{echodissect} you can see the output when
I run the command \verb|ping 127.0.0.1| which the code in figure\ref{echorecv} is listening for
packets.

\begin{lstlisting}[label=echosend,caption=A prototype for sending \gls{icmp} ECHO REQUEST packets.]
#!/usr/bin/python3.7
import socket
import struct
import os
import time
import array

from os import getcwd, getpid
import sys
sys.path.append("../modules/")

import ip_utils


ICMP_ECHO_REQUEST = 8

# opens a raw socket for the ICMP protocol
ping_sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
# allows manual IP header creation
# ping_sock.setsockopt(socket.SOL_IP, socket.IP_HDRINCL, 1)

ID = os.getpid() & 0xFFFF

# the two zeros are the code and the dummy checksum, the one is the sequence number
dummy_header = struct.pack("bbHHh", ICMP_ECHO_REQUEST, 0, 0, ID, 1)

data = struct.pack("d", time.time()) + bytes((192 - struct.calcsize("d")) * "A", "ascii")

checksum = ip_utils.ip_checksum(dummy_header+data)

header = struct.pack("bbHHh", ICMP_ECHO_REQUEST, 0, checksum, ID, 1)

packet = header + data

ping_sock.sendto(packet, ("127.0.0.1", 1))
\end{lstlisting}

\begin{lstlisting}[label=echorecv,caption=A prototype for receiving \gls{icmp} ECHO REQUEST packets.]
#!/usr/bin/python3.7

import socket
import struct
import time
from typing import List

# socket object using an IPV4 address, using only raw socket access, set ICMP protocol        
ping_sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)

packets: List[bytes] = []

while len(packets) < 1:
    recPacket, addr = ping_sock.recvfrom(1024)
    ip_header = recPacket[:20]
    icmp_header = recPacket[20:28]

    ip_hp_ip_v, ip_dscp_ip_ecn, ip_len, ip_id, ip_flgs_ip_off, ip_ttl, ip_p, ip_sum, ip_src, ip_dst = struct.unpack('!BBHHHBBHII', ip_header)

    hl_v = f"{ip_hp_ip_v:08b}"
    ip_v = int(hl_v[:4], 2)
    ip_hl = int(hl_v[4:], 2)
    dscp_ecn = f"{ip_dscp_ip_ecn:08b}"
    ip_dscp = int(dscp_ecn[:6], 2)
    ip_ecn = int(dscp_ecn[6:], 2)
    flgs_off = f"{ip_flgs_ip_off:016b}"
    ip_flgs = int(flgs_off[:3],2)
    ip_off = int(flgs_off[3:], 2)
    src_addr = socket.inet_ntoa(struct.pack('!I', ip_src))
    dst_addr = socket.inet_ntoa(struct.pack('!I', ip_dst))

    print("IP header:")
    print(f"Version: [{ip_v}]\nInternet Header Length: [{ip_hl}]\nDifferentiated Services Point Code: [{ip_dscp}]\nExplicit Congestion Notification: [{ip_ecn}]\nTotal Length: [{ip_len}]\nIdentification: [{ip_id:04x}]\nFlags: [{ip_flgs:03b}]\nFragment Offset: [{ip_off}]\nTime To Live: [{ip_ttl}]\nProtocol: [{ip_p}]\nHeader Checksum: [{ip_sum:04x}]\nSource Address: [{src_addr}]\nDestination Address: [{dst_addr}]\n")

    msg_type, code, checksum, p_id, sequence = struct.unpack('!bbHHh', icmp_header)
    print("ICMP header:")
    print(f"Type: [{msg_type}]\nCode: [{code}]\nChecksum: [{checksum:04x}]\nProcess ID: [{p_id:04x}]\nSequence: [{sequence}]"
    packets.append(recPacket)
open("current_packet", "w").write("\n".join(" ".join(map(lambda x: "{x:02x}", map(int, i))) for i in packets))
\end{lstlisting}
\begin{lstlisting}[label=checksum,caption=A function for calculating the IP checksum for a set of btyes.]
def ip_checksum(packet: bytes) -> int:
    """
    ip_checksum function takes in a packet
    and returns the checksum.
    """
    if len(packet) % 2 == 1:
        # if the length of the packet is even, add a NULL byte
        # to the end as padding
        packet += b"\0"

    total = 0
    for first, second in (
            packet[i:i+2]
            for i in range(0, len(packet), 2)
    ):
        total += (first << 8) + second

    # calculate the number of times a
    # carry bit was added and add it back on
    carried = (total - (total & 0xFFFF)) >> 16
    total &= 0xFFFF
    total += carried

    if total > 0xFFFF:
        # adding the carries generated a carry
        total &= 0xFFFF

    # invert the checksum and take the last 16 bits
    return (~total & 0xFFFF)
\end{lstlisting}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{deconstructed_headers.png}
  \caption{%
    Dissecting an \gls{icmp} ECHO REQUEST packet.
  }\label{echodissect}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{ping_send_success.png}
  \caption{%
    Screenshot of wireshark showing a successful send of an \gls{icmp} ECHO REQUEST packet.
  }\label{pingsuccess}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{local_self_ping.png}
  \caption{%
    Screenshot showing me first successfully dissecting an \gls{icmp} ECHO REQUEST packet.
  }\label{dissectsuccess}
\end{figure}

Having done these prototypes I have identified that it would probably be best to abstract the
code for dissecting all the headers i.e.\ \gls{icmp}, \gls{tcp} and \gls{ip} into classes
where I can just pass the received packet into the class and have it dissect it for me and then
I will also get access to some of the benefits of classes such as the \verb|__repr__| method
which is called when you print classes out and allows me to control what is printed out.
Before I started to write the final piece I wanted to make a prototype ping scanner, as this
would allow me to get a feel for making a scanner as well as further exploring low level protocol
interactions.

\begin{lstlisting}[label=pingscan,caption=An attempt at making a ping scanner.]
#!/usr/bin/python3.7
from os import getcwd, getpid
import sys
sys.path.append("../modules/")

import ip_utils

import socket
from functools import partial
from itertools import repeat
from multiprocessing import Pool
from contextlib import closing
from math import log10, floor
from typing import List, Tuple
import struct
import time


def round_significant_figures(x: float, n: int) -> float:
    """
    rounds x to n significant figures.
    round_significant_figures(1234, 2) = 1200.0
    """
    return round(x, n-(1+int(floor(log10(abs(x))))))


def recieved_ping_from_addresses(ID: int, timeout: float) -> List[Tuple[str, float, int]]:
    """
    Takes in a process id and a timeout and returns the list of addresses which sent
    ICMP ECHO REPLY packets with the packed id matching ID in the time given by timeout.
    """
    ping_sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
    time_remaining = timeout
    addresses = []
    while True:
        time_waiting = ip_utils.wait_for_socket(ping_sock, time_remaining)
        if time_waiting == -1:
            break
        time_recieved = time.time()
        recPacket, addr = ping_sock.recvfrom(1024)
        ip_header = recPacket[:20]
        ip_hp_ip_v, ip_dscp_ip_ecn, ip_len, ip_id, ip_flgs_ip_off, ip_ttl, ip_p, ip_sum, ip_src, ip_dst = struct.unpack('!BBHHHBBHII', ip_header)
        icmp_header = recPacket[20:28]
        msg_type, code, checksum, p_id, sequence = struct.unpack('bbHHh', icmp_header)
        time_remaining -= time_waiting
        time_sent = struct.unpack("d", recPacket[28:28+struct.calcsize("d")])[0]
        time_taken = time_recieved - time_sent
        if p_id == ID:
            addresses.append((str(addr[0]), float(time_taken), int(ip_ttl)))
        elif time_remaining <= 0:
            break
        else:
            continue
    return addresses


with closing(socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)) as ping_sock:
    addresses = ip_utils.ip_range("192.168.1.0/24")
    local_ip = ip_utils.get_local_ip()
    if addresses is not None:
        addresses_to_scan = filter(lambda x: x!=local_ip, addresses)
    else:
        print("error with ip range specification")
        exit()
    p = Pool(1)
    ID = getpid()&0xFFFF
    replied = p.apply_async(recieved_ping_from_addresses, (ID, 2))
    for address in zip(addresses_to_scan, repeat(1)):
        try:
            packet = ip_utils.make_icmp_packet(ID)
            ping_sock.sendto(packet, address)
        except PermissionError:
            pass
    p.close()
    p.join()
    hosts_up = replied.get()
    print("\n".join(map(lambda x: f"host: [{x[0]}]\tresponded to an ICMP ECHO REQUEST in {round_significant_figures(x[1], 2):<10} seconds, ttl: [{x[2]}]", hosts_up)))
\end{lstlisting}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{pingscan.png}
  \caption{%
    Screenshot of wireshark showing a successful ping scan.
  }\label{pingscansuccess}
\end{figure}

\lstset{language=C}
\begin{lstlisting}[label=pingscanout,caption=The output of from the ping scanner on the run which generated the \gls{pcap} file in figure~\ref{pingscansuccess}]
$ sudo ./ping_scan.py
host: [192.168.1.1]	responded to an ICMP ECHO REQUEST in 0.00037    seconds, ttl: [64]
host: [192.168.1.35] responded to an ICMP ECHO REQUEST in 0.00042    seconds, ttl: [128]
host: [192.168.1.37] responded to an ICMP ECHO REQUEST in 0.002      seconds, ttl: [64]
host: [192.168.1.117] responded to an ICMP ECHO REQUEST in 0.0017     seconds, ttl: [64]
host: [192.168.1.176] responded to an ICMP ECHO REQUEST in 0.0014     seconds, ttl: [254]
host: [192.168.1.14] responded to an ICMP ECHO REQUEST in 0.0072     seconds, ttl: [64]
host: [192.168.1.246] responded to an ICMP ECHO REQUEST in 0.049      seconds, ttl: [64]
host: [192.168.1.8] responded to an ICMP ECHO REQUEST in 0.099      seconds, ttl: [64]
\end{lstlisting}

Now that I have done these prototypes I am fairly certain about how I will structure the rest of
my scanners, how to interact with Python's socket programming interface and how I can use the
struct module to make and dissect packets. My general plan for the scanners will be to start
a process that listens for responses for a set amount of time and then start sending the packets
in a different process before waiting for the listening process to get all the responses back and
collecting the results from that process.

\subsection{Acceptable Limitations}

Originally I had planned to include dedicated operating system detection as an option
however I ran out of time having implemented version detection. However it still does
Operating system detection partially as some \glspl{service} are linux only and while doing
\gls{service} and version detection especially the \gls{cpe} parts
of the matched \gls{service}/version will contain operating system information, such as
microsoft ActiveSync would indicate that the system being scanned was a windows system
which is reflected in the match directive and attached CPE information:
\begin{verbatim}
match activesync m|^.\0\x01\0[^\0]\0[^\0]\0[^\0]\0[^\0]\0[^\0]\0.*
\0\0\0$|s p/Microsoft ActiveSync/ o/Windows/ cpe:/a:microsoft:acti
vesync/ cpe:/o:microsoft:windows/a
\end{verbatim}

\subsection{Test Strategy}

I am going to use two different methods to test my program:
\begin{enumerate}
\item{Unit testing}
\item{Wireshark}
\end{enumerate}
I am using two separate testing strategies because they are both good at different things,
both of which I need to show that my project works. Firstly I am using unit testing to test
some general purpose functions which are pure functions (are independent of the current state
of the machine) such as \verb|ip_range()| and other functions which I can just check the returned
value against what it should be.

Wireshark is useful for the other half of the program which uses impure functions and the low level 
networking e.g.\ \verb|make_tcp_packet()|. Wireshark makes this easy by allowing capture of all the 
\glspl{pkt} going over the wire, as well as this it has a vast array of \gls{pkt} decoders (2231 in 
my install) which it can use to dissect almost any \gls{pkt} that would be on the network. The main 
benefit of wireshark is that I can see my scanners sending \glspl{pkt} and then check whether the 
parsers that I have written for the different protocols are working. I can also check that the 
\glspl{csum} in each of the various protocols is valid as wireshark does \gls{csum} verification for 
various protocols. 

I will be running these tests on my laptop which is a thinkpad T480 running arch linux
with kernel version 5.0.7. I am using wireshark version 3.1.0, Python version 3.7.2 and
pytest version 4.3.1. I am also using pyenv version 1.2.9 to manage the version of python in
my python environment. I am using no modules outside of the python standard library so that
my program is as portable as possible and its functionality is as reproducible as possible.

To do the unit testing side of my testing you will need python 3.7.2 and pytest 4.3.1
to run the tests you will need to run python -m pytest inside the Code directory, this will
call pytest and then it will find the tests inside the tests directory and run them, it
will then display the number of tests that passed along with lots of information on the
tests that failed such as what the arguments were etc\ldots Pytest does this via introspection
of the comparison and assert commands, this means that it uses its own versions of those commands
which allow it to get more information out about what went wrong. Such as which element in a list
was the one that caused the comparison to return false etc.

The wireshark side of the testing you will need a version of wireshark and iptables.
You will then need to set up wireshark in listen mode on the right interface so that it
captures the packets that my program is sending, from there you can inspect the sent packets and
determine whether they fit what was expected in the test description or whether they don't match at
all. For filtered packet tests you will need to run the command \verb|iptables -I INPUT -s 127.0.0.1 -j DROP|
and scan the localhost address and after the test you need to run the \verb|iptables -F| command
to flush all the iptables rules to prevent any confusion in future caused by an firewall rule
that shouldn't be there.

\section{Design}

\subsection{Overall System Design (High Level Overview)}

There are two types of scanning implemented for different scan types in my program.
\begin{itemize}
  \item{\verb|Connect()|}
  \item{version}
  \item{listener / sender}
\end{itemize}
\verb|Connect()| scanning is the simplest in that it takes in a list of \glspl{port} and simply 
calls the \verb|socket.connect()| method on it and sees whether it can connect or not and the 
\glspl{port} are marked accordingly as open or closed. 

Version scanning is very similar to \verb|Connect()| scanning in that it takes in a list of 
\glspl{port} and connects to them, except it then sends a probe to the target to elicit a response 
and gain some information about the \gls{service} running behind the \gls{port}.

Listener / sender scanning does exactly what it says on the tin: it sets up a ``listener'' in 
another process to listen for responses from the host which the ``sender'' is sending \glspl{pkt} 
to. It can then differentiate between open, open|filtered, filtered and closed \glspl{port} based on 
whether it receives a \gls{pkt} back and what flags (part of\gls{tcp} \glspl{pkt} are a one byte 
long section which store ``flags'' where each bit in the byte represents a different flag) are set 
in the received \gls{pkt}. 

\subsection{Design of User Interfaces HCI}

I have designed my system to have a similar interface to the most common tool currently used: nmap.
This is because I believe that having a familiar interface will not only make it easier for someone 
who is familiar with nmap to use my tool it also makes it so that anything learnt using either tool 
is applicable to both which benefits everyone.

Based on this perception I have used the same option flags as nmap as well as similar help messages 
and an identical call signature (how the program is used on the command line). Running 
\verb|./netscan.py <options> <target_spec>| is identical to \verb|nmap <options> <target_spec>| in 
terms of which scan types will be run, which hosts will be scanned and which \glspl{port} are 
scanned. Below you can see the help message generated by \verb|./netscan.py --help|.

\begin{verbatim}
usage: netscan.py [-h] [-Pn] [-sL] [-sn] [-sS] [-sT] [-sU] [-sV] [-p PORTS]
                  [--exclude_ports EXCLUDE_PORTS]
                  target_spec

positional arguments:
  target_spec           specify what to scan, i.e. 192.168.1.0/24

optional arguments:
  -h, --help            show this help message and exit
  -Pn                   assume hosts are up
  -sL                   list targets
  -sn                   disable port scanning
  -sS                   TCP SYN scan
  -sT                   TCP connect scan
  -sU                   UDP scan
  -sV                   version scan
  -p PORTS, --ports PORTS
                        scan specified ports
  --exclude_ports EXCLUDE_PORTS
                        ports to exclude from the scan
\end{verbatim}

It shows clearly which are required arguments and which are optional ones, as well as what
each argument actually does. It also allows some some arguments to be called with either
a short format e.g.\ \verb|-p| and with a most verbose format \verb|--ports| this allows
the user to be clearer if they are using the tool as part of an automated script to perform
scanning as it should be more immediately obvious what the more verbose flags do.
If the user enters erroneous data they will normally be greeted by a python ValueError
which explains exactly what the issue was with their input and prints the offending parameter.

\subsection{System Algorithms}

\begin{figure}[H]
  \centering
  \begin{framed}
    \begin{tikzpicture}[node distance=2cm]
      \node [startstop] (start) {start};
      \node [io, below of=start, text width=3cm] (input) {get addresses to scan};
      \node [process, below of=input] (listener) {start listener};
      \node [decision, below of=listener, text width=3cm, yshift=-0.8cm] (loop) {are there more addresses to scan?};
      \node [process, right of=loop, xshift=3.2cm] (get) {get the next address to scan};
      \node [io, below of=get, text width=3cm] (send) {send \gls{icmp} ECHO REQUEST};
      \node [process, below of=loop, yshift=-2cm] (wait) {wait for listener to return results};
      \node [process, below of=wait] (output) {return the results to the user};
      \node [startstop, below of=output] (end) {end};

      \draw [arrow] (start) -- (input);
      \draw [arrow] (input) -- (listener);
      \draw [arrow] (listener) -- (loop);
      \draw [arrow] (loop) -- node[midway,above,xshift=-0.2cm] {yes} (get);
      \draw [arrow] (get) -- (send);
      \draw [arrow] (send) -| node[midway,above,xshift=2cm] {} (loop);
      \draw [arrow] (loop) -- ([xshift=-1cm]loop.west) node[above,xshift=0.5cm] {no} -- ([xshift=-1cm,yshift=-2.5cm]loop.west) -| (wait);
      \draw [arrow] (wait) -- (output);
      \draw [arrow] (output) -- (end);

    \end{tikzpicture}
  \end{framed}
  \caption{%
    The logic for how I will do Ping Scanning.
  }\label{pingscanflow}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{framed}
    \begin{tikzpicture}[node distance=2cm]
      \node [startstop] (start) {start};
      \node [io, below of=start] (get) {get ports to scan};
      \node [io, below of=get, text width = 5cm,yshift=-0.2cm] (connect) {attempt to connect to the next port with \verb|socket.connect|};
      \node [decision, below of=connect, text width=3cm, yshift=-1cm] (save) {did the connection succeed?};
      \node [process, right of=save, xshift=3cm] (add) {save port to list of open ports};
      \node [decision, below of=save, text width=3cm, yshift=-1.5cm, xshift=2cm] (loop) {are there more ports to scan?};
      \node [process, below of=loop, yshift=-0.8cm, text width=5cm] (return) {return the list of ports which were successfully connected to.};
      \node [startstop, below of=return] (end) {end};

      \draw [arrow] (start) -- (get);
      \draw [arrow] (get) -- (connect);
      \draw [arrow] (connect) -- (save);
      \draw [arrow] (save) -- node[midway,above,xshift=-0.1cm] {yes} (add);
      \draw [arrow] (save) |- node[midway, below] {no} ([yshift=0.5cm]loop.north) -- (loop);
      \draw [arrow] (add) |- ([yshift=0.5cm]loop.north) -- (loop);
      \draw [arrow] (loop) -| node[midway, above, xshift=-1.5cm] {yes} ([xshift=5cm,yshift=1cm]connect.east) -| (connect.north);
      \draw [arrow] (loop) -- node[midway, right] {no} (return);
      \draw [arrow] (return) -- (end);

    \end{tikzpicture}
  \end{framed}
  \caption{%
    The logic for how I will do TCP connect Scanning.
  }\label{tcpconnectscanflow}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{framed}
    \begin{tikzpicture}[node distance=2cm]
      \node [startstop] (start) {start};
      \node [io, below of=start, text width=3cm] (input) {get ports to scan};
      \node [process, below of=input] (listener) {start listener};
      \node [decision, below of=listener, text width=3cm, yshift=-0.8cm] (loop) {are there more ports to scan?};
      \node [process, right of=loop, xshift=3.2cm] (get) {get the next port to scan};
      \node [io, below of=get, text width=3cm] (send) {send \gls{tcp} SYN packet};
      \node [process, below of=loop, yshift=-2cm] (wait) {wait for listener to return results};
      \node [process, below of=wait] (output) {return the results to the user};
      \node [startstop, below of=output] (end) {end};

      \draw [arrow] (start) -- (input);
      \draw [arrow] (input) -- (listener);
      \draw [arrow] (listener) -- (loop);
      \draw [arrow] (loop) -- node[midway,above,xshift=-0.2cm] {yes} (get);
      \draw [arrow] (get) -- (send);
      \draw [arrow] (send) -| node[midway,above,xshift=2cm] {} (loop);
      \draw [arrow] (loop) -- ([xshift=-1cm]loop.west) node[above,xshift=0.5cm] {no} -- ([xshift=-1cm,yshift=-2.5cm]loop.west) -| (wait);
      \draw [arrow] (wait) -- (output);
      \draw [arrow] (output) -- (end);

    \end{tikzpicture}
  \end{framed}
  \caption{%
    The logic for how I will do TCP SYN scanning.
  }\label{tcpsynscanflow}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{framed}
    \begin{tikzpicture}[node distance=1.5cm]
      \node [startstop] (start) {start};
      \node [io,below of=start] (get) {get ports to scan};
      \node [process, below of=get] (udp listener) {start udp listener};
      \node [io, below of=udp listener, inner sep=0] (send 1) {send next \gls{udp} packet};
      \node [decision, below of=send 1, text width=2cm, yshift=-0.2cm] (loop 1) {more ports to scan?};
      \node [decision, below of=loop 1, left=0.5cm of loop 1, yshift=-0.3cm] (loop 2) {on second loop?};
      \node [process, right=0.7cm of loop 2] (udp wait) {wait for \gls{udp} listener};
      \node [process, below=0.5cm of udp wait] (icmp listener) {start \gls{icmp} listener};
      \node [io, below=0.5cm of icmp listener, inner sep=0] (send 2) {send next \gls{udp} packet};
      \node [process, below=0.5cm of send 2] (icmp wait) {wait for \gls{icmp} listener};
      \node [decision, below=0.5cm of icmp wait, text width = 2cm] (loop 3) {more ports to scan?};
      \node [process, left=0.5cm of loop 3] (return) {return results};
      \node [startstop, below=0.5cm of return] (end) {end};

      \draw [arrow] (start) -- (get);
      \draw [arrow] (get) -- (udp listener);
      \draw [arrow] (udp listener) -- (send 1);
      \draw [arrow] (send 1) -- (loop 1);
      \draw [arrow] (loop 1.east) -| ([xshift=1cm,yshift=0.75cm]send 1.east) node [right,yshift=-1.25cm] {yes} -| (send 1.north);
      \draw [arrow] (loop 1) -| node [above, xshift=1cm] {no} (loop 2);
      \draw [arrow] (loop 2.west) -| ([xshift=-4cm,yshift=0.75cm]send 1.west) node [left,yshift=-2cm] {no} -| (send 1.north);
      \draw [arrow] (loop 2) -- node [xshift=-0.1cm,above] {yes} (udp wait);
      \draw [arrow] (udp wait) -- (icmp listener);
      \draw [arrow] (icmp listener) -- (send 2);
      \draw [arrow] (send 2) -- (icmp wait);
      \draw [arrow] (icmp wait) -- (loop 3);
      \draw [arrow] (loop 3.east) -| ([xshift=1cm,yshift=0.75cm]icmp listener.east) node [right,yshift=-3cm] {yes} -| (icmp listener);
      \draw [arrow] (loop 3) -- node [above,xshift=0.1cm] {no} (return);
      \draw [arrow] (return) -- (end);

    \end{tikzpicture}
  \end{framed}
  \caption{%
    The logic behind how \gls{udp} scanning works.
  }\label{udpscanflow}
\end{figure}


\begin{figure}[H]
  \centering
  \begin{framed}
    \begin{tikzpicture}[node distance=1.5cm]
      \node [startstop] (start) {start};
      \node [io, right=1.5cm of start, text width=2cm] (get ports) {get ports to scan};
      \node [io, below=0.5cm of get ports, text width=2.5cm] (parse probes) {read and parse probe file};
      \node [process, below=0.5cm of parse probes] (send probe) {send the next probe};
      \node [process, below=0.5cm of send probe] (wait) {wait for response};
      \node [process, below=0.5cm of wait] (softmatch) {try to softmatch response};
      \node [decision, below=0.5cm of softmatch, text width=2.5cm] (softmatched) {did softmatch succeed?};
      \node [process, below=0.5cm of softmatched] (match) {try to match response};
      \node [decision, left=1cm of match, text width=2.5cm] (softmatch loop) {are there more softmatches?};
      \node [decision, below=0.5cm of match, text width=2cm] (matched) {did match succeed?};
      \node [decision, below=0.5cm of matched, text width=2.5cm] (match loop) {are there more matches};
      \node [decision, left=0.5cm of match loop, text width=2.5cm] (probe loop) {are there more probes?};
      \node [process, below=0.5cm of probe loop] (return) {return results};
      \node [startstop, below=0.5cm of match loop] (end) {end};

      \draw [arrow] (start) -- (get ports);
      \draw [arrow] (get ports) -- (parse probes);
      \draw [arrow] (parse probes) -- (send probe);
      \draw [arrow] (send probe) -- (wait);
      \draw [arrow] (wait) -- (softmatch);
      \draw [arrow] (softmatch) -- (softmatched);
      \draw [arrow] (softmatched.east) -| node[above] {yes} ([yshift=0.75cm,xshift=0.75cm]match.east) -| (match);
      \draw [arrow] (softmatched) -| node[above, xshift=1.25cm] {no} (softmatch loop);
      \draw [arrow] (softmatch loop) -- node [above, xshift=-0.1cm] {no} (match);
      \draw [arrow] (softmatch loop)-|node[right,yshift=2.5cm]{yes}([xshift=-5.25cm,yshift=0.75cm]softmatch.west)-|(softmatch);
      \draw [arrow] (match) -- (matched);
      \draw [arrow] (match loop) -| node [right,] {yes} ([xshift=0.75cm,yshift=0.75cm] match.east) -| (match.north);
      \draw [arrow] (matched) -- node [right] {no} (match loop);
      \draw [arrow] (match loop) -- node [above, yshift=0.1cm] {no} (probe loop);
      \draw [arrow] (matched) -| node [above, xshift=1.35cm] {yes} (probe loop);
      \draw [arrow] (probe loop) -| node [left,yshift=5.5cm] {yes} ([xshift=-6cm,yshift=0.75cm]send probe.west) -| (send probe);
      \draw [arrow] (probe loop) -- node [midway, right, yshift=0.1cm] {no} (return);
      \draw [arrow] (return) -- (end);

    \end{tikzpicture}
  \end{framed}
  \caption{%
    The logic behind how version detection works.
  }\label{versiondetectflow}
\end{figure}


\subsection{Input data Validation}

I perform data validation in all of the functions in the fundamental modules
which I have made. This is because a lot of the functionality of my project
is based around the code in these modules so I need to know if I am passing
bad input data to a function. So that I know there is a bug that I need to
fix. This also helps when the program is interacting with the user if it
detects invalid data it will raise a ValueError which is python's error
message for when an error is raised because the data passed in has the
incorrect value, for example trying to turn the string \verb|"I love apples"|
into an integer value will result in the error message:
\verb|ValueError: invalid literal for int() with base 10: 'I love apples'|
This informs you that you have tried to turn \verb|"I love apples"|
into an integer with base 10 and it is invalid. An example from
my code would be if I were to ask it to print out a subnet with 33 network
bits it will raise a value error as network bits must be between 0 and 32.
This is shown in figure~\ref{validation}.
In general there are very few pieces of data that the user enters which can be erroneous,
the user enters the IP address to scan, the ports to scan and the number of network bits
in the case of a subnet. My program has functions which are used for verifying each of
these, for the case of port numbers and IP addresses I have explicit functions which
do this: \verb|def is_valid_port_number(port_num: int) -> bool:| and
\verb|def is_valid_ip(ip: Union[str, int]) -> bool:|. For network bits they are validated
inside of the function which generates the range of IP addresses for a subnet by a simple
check on whether the number of network bits is between 0 and 32.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{validation.png}
  \caption{%
    A screenshot of the output of my code when asked to translate a subnet with 33 network bits.
  }\label{validation}
\end{figure}

\subsection{Algorithm for complex structures}

\begin{algorithm}
  \caption{%
  My algorithm for turning a \gls{cidr} specified \gls{subnet} into a list of actual \gls{ipaddr}es
}\label{ip_range}
  \begin{algorithmic}[1]
    \Procedure{ip\_range}{}
    \State{$\textit{network\_bits} \gets \text{number of network bits specified}$}
    \State{$\textit{ip} \gets \text{base IP address}$}
    \State{$\textit{mask} \gets 0$}
    \For{$\textit{maskbit} \gets (32-\textit{network\_bits}),31$}
      \State{$\textit{mask} \gets \textit{mask} + 2^\textit{maskbit}$}
    \EndFor{}
    \State{$\textit{lower\_bound} \gets \text{\textit{ip} AND \textit{mask}}$}
    \Comment{zero the last 32-\textit{network\_bits}}
    \State{$\textit{upper\_bound} \gets \text{\textit{ip} OR (\textit{mask} XOR 0xFFFFFFFF)}$}
    \Comment{turn the last 32-\textit{network\_bits} to ones}
    \State{$\textit{addresses} \gets \text{empty list}$}
    \For{$\textit{address} \gets \textit{lower\_bound},\textit{upper\_bound}$}
      \State{append \Call{convert\_to\_dot}{\textit{address}} to \textit{addresses}}
    \EndFor{}
    \Return{\textit{addresses}}
    \EndProcedure{}
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{%
    My algorithm for pretty-printing a dictionary of lists of\gls{port}numbers
    such that ranges are specified as start-end instead of start,start+1,\ldots,end
  }\label{collapse}
  \begin{algorithmic}[1]
  \Procedure{collapse}{}
    \State{$\textit{port\_dictionary} \gets \text{dictionary of lists of\gls{port}numbers}$}
    \State{$\textit{key\_results} \gets \text{empty list}$}
    \Comment{stores the formatted result for each key}
    \For{\textit{key} in \textit{port\_dictionary}}
      \State{$\textit{ports} \gets \text{\textit{port\_dict}[\textit{key}]}$}
      \State{$\textit{result} \gets \textit{key} + \text{``:\{''}$}
      \If{\textit{ports} is empty}
        \State{$\textit{new\_sequence} \gets FALSE$}
        \For{$\textit{index} \gets 1,\text{(length of \textit{ports})}-1$}
          \State{$\textit{port} = \text{\textit{ports}[\textit{index}]}$}
          \If{$\textit{index} = 0$}
            \State{$\textit{result} \gets \textit{result} + \textit{ports}[0]$}
            \Comment{append the first element}
            \If{$\text{\textit{ports}[\textit{index}+1]} = \textit{port} + 1$}
              \State{$\textit{result} \gets \textit{result}+\text{``-''}$}
              \Comment{begin a new sequence}
            \Else{}
              \State{$\textit{result} \gets \textit{result} + \text{``,''}$}
              \Comment{not a sequence}
            \EndIf{}
          \ElsIf{$\textit{port} + 1 \not= \text{\textit{ports}[\textit{index}+1]}$}
          \Comment{break in sequence}
            \State{$\textit{result} \gets \textit{result} + \textit{port} + \text{``,''}$}
            \State{$\textit{new\_sequence} \gets \textit{TRUE}$}
          \ElsIf{$\textit{port}+1 = \text{\textit{ports}[\textit{index}+1]} \And \textit{new\_sequence}$}
            \State{$\textit{result} \gets \textit{result} + \text{``-''}$}
            \State{$\textit{new\_sequence} \gets \textit{FALSE}$}
          \EndIf{}
        \EndFor{}
      \State{$\textit{result} \gets \textit{result} + \text{\textit{ports}[(length of \textit{ports})-1]} + \text{``\}''}$}
      \State{append \textit{result} to \textit{key\_results}}
      \EndIf{}
    \EndFor{}
    \Return{``\{'' + (\textit{key\_results} separated by ``, '') + ``\}''}
  \EndProcedure{}
  \end{algorithmic}
\end{algorithm}

\section{Technical Solution}
I have placed all of my code in Appendix~\ref{code}. This is because it takes up 60 odd pages
and as such it would make it a pain to have to page through to get to the testing section.
However I will be going through each of the items in this appendix and explaining what they do.

Appendix~\ref{app:icmpping} contains all the code which I wrote while in an early experimentation
phase where I was testing out how I was planning to make and structure the project.

Appendix~\ref{app:pingscanner} contains all the code which I wrote while writing my initial prototype
of my ping scanner which uses \gls{icmp} ECHO REQUEST messages to detect hosts which are online on a given
subnet.
It is used to meet success criteria~\ref{ping}.

Appendix~\ref{app:subnettoaddresses} contains all the code which I wrote while writing a tool which
can translate a \gls{cidr} specified subnet into the list of \gls{ip} addresses for that subnet,
it has logic to exclude the broadcast address and host addresses for each subnet.
This is used to meet success criteria~\ref{cidr}.

Appendix~\ref{app:tcpscan} contains all of the prototypes for \gls{tcp} based scanning which are contained
in the sub Appendices~\ref{app:connectscan} and~\ref{app:synscan}. Appendix~\ref{app:connectscan} contains
all of the code which I created whilst prototyping connect scanning. It satisfies success criteria~\ref{tcpopen}
and~\ref{tcpclosed}. Appendix~\ref{app:synscan} contains all of the code I wrote while prototyping \gls{tcp} SYN
scanning. It satisfies success criteria~\ref{tcpopen},~\ref{tcpclosed} and~\ref{tcpfiltered}.

Appendix~\ref{app:udpscan} contains all of the code I wrote while prototyping \gls{udp} scanning.
It satisfies success criteria~\ref{udpopen},~\ref{udpclosed} and~\ref{udpfiltered}.

Appendix~\ref{app:versiondetection} contains all of the code I wrote while prototyping version detection
scanning. It satisfies success criteria~\ref{servicedetect} and~\ref{versiondetect}.

Appendix~\ref{app:modules} contains all of the modules I wrote to help me make me with creating
my main application which I will come on to later. These modules mainly contain code which I reuse often
such as code to calculate an ip checksum or validate an \gls{ipaddr}.

Appendix~\ref{app:examples} contains a script I wrote which will run each of the prototype applications I
made. This doesn't satisfy any of the success criteria but was very useful for solving issues I had with
importing python modules where due to the directory structure everything as to do started from the root of
the directory structure otherwise everything goes a bit mad, and this was my solution for running everything
at the root of the directory structure as this sits at the root and can call the \verb|main()| function
defined in each of the modules along with also being able to import all of the modules in the modules directory.

Appendix~\ref{app:netscan} contains the code for my final application which satisfies all of the success
criteria bar~\ref{osdetect} which is partially completed via version detect scanning.

Appendix~\ref{app:tests} contains all of the for my unit tests which I run using \verb|python -m pytest|
and it automatically goes and runs each function and can give me verbose information on each one.
I have named all of the test functions in a very verbose way and I only test one thing in each function.
This means that it is much easier for me to read from the name of a failed test exactly what went wrong
with what function and what argument caused it. An example of this can be seen in figure~\ref{testing}
where I have changed on of the tests so that it fails. You can see in that it shows me a clear difference
between what was expected on one side of the assertion statement and then what actually happened on the
other side. In this case it shows that in the left set there is an extra element of 192.168.1.1 and in
the right an extra element of 192.168.1.0, this is very helpful for preventing regressions in the code
where I would write feature and accidentally break another piece of functionality.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{testing.png}
  \caption{%
    A screenshot of running pytest with a deliberately broken test.
  }\label{testing}
\end{figure}

\section{Testing}

\subsection{Test Plan}

I will be testing my application using a combination of unit tests and wireshark where applicable.
Unit tests are more suitable to doing tests on specific functions to make sure that regressions don't occur while developing
the application. A regression is a when a feature or change that was implemented into the program is by accident and would 
cause the application to break. Wireshark I will use to show the scanning portion of my code and where external connections
are made/custom packets created. The following are the tests using wireshark,
the unit tests are in Appendix~\ref{app:tests}.

\subsection{Testing Evidence}

\subsubsection{Printing a usage message when run without parameters}

To show this I will run my program passing it no parameters.
This should print out a message of the form: \verb|USAGE: ./<program> <required> <parameters>|
where everything in angle brackets should be replaced by what is necessary for my program. 
In figure~\ref{noparametertest} you can see me run \verb|./netscan.py| with no parameters and it
prints out the required usage message telling me that I am missing the target\_spec parameter, this
shows that it passed this test.
This shows success criteria~\ref{usage}.
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{noparameters.png}
  \caption{%
    Screenshot showing my program being run without parameters.
  }\label{noparametertest}
\end{figure}

\subsubsection{Printing a help message when passed -h}

To show this I will run my program with the \verb|-h| flag.
This should print out a message showing each of the options as well as what each of them do.
It should also print out whether they are positional arguments or optional arguments and if
an argument can have two forms then it should print out both forms of the flag, i.e. \verb|-p --ports|.
In figure~\ref{hflagtest} you can see me run my program with the \verb|-h| flag and it proceeds to
print of a help message with messages with what each option is for as well as short and long form of
arguments, this shows my program passed this test.
This shows success criteria~\ref{usage}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{hmessage.png}
  \caption{%
    Screenshot showing my program being run with the -h flag.
  }\label{hflagtest}
\end{figure}

\subsubsection{Printing a help message when passed -help}
To show this I will run my program with the \verb|--help| flag.
This should produce the exact same output as with \verb|-h|.
This shows the exact same message as in the test of \verb|-h|.
To prove this if I take the sha1sum of the output for both flags we can see
that the hashes are identical and therefore the originals were also identical,
this is shown in figure~\ref{messagehash}.
This shows success criteria~\ref{usage}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{helpmessage.png}
  \caption{%
    Screenshot showing my program being run with the help flag.
  }\label{helpflagtest}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{messagehashes.png}
  \caption{%
    Screenshot showing the hashes of the two help messages.
  }\label{messagehash}
\end{figure}

\subsubsection{Scanning a subnet with ICMP ECHO REQUEST messages}
To show this I will run my program with the \verb|-sn| flag and specify the
subnet of my local network \verb|192.168.178.0/24|.
This should produce a list of all the hosts which are up on the network.
In figure~\ref{lanscantest} you can see you can see my program's output
showing that the hosts:
\begin{itemize}
  \item{192.168.178.60}
  \item{192.168.178.56}
  \item{192.168.178.30}
  \item{192.168.178.1}
\end{itemize}
all responded with \gls{icmp} ECHO REPLY messages, this is reflected
in a packet capture I took while performing the scan. A section of this
scan is shown in figure~\ref{lanscanwireshark} where you can see some of
\gls{icmp} ECHO REQUEST messages my program sent, along with some of the requests
to hosts that don't exist, note the different addresses in the source and destination fields
and the Echo (ping) request vs reply in the info column. This successfully shows success
criteria~\ref{blackbox} and~\ref{ping}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{pingscantest.png}
  \caption{%
    Screenshot showing the output of a scan of my local network.
  }\label{lanscantest}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{pingscantest_wireshark.png}
  \caption{%
    Screenshot showing a selection of the packets being sent by this scan.
  }\label{lanscanwireshark}
\end{figure}

\subsubsection{Translating a CIDR specified subnet into a list of IP addresses}
To show this I will run my program with the \verb|-sL| flag and I will specify
a small subnet of \verb|192.168.1.0/28| (I have chosen such a small subnet
such that it will fit on my terminal and therefore in a screenshot).
I expect the list of addresses to be \verb|192.168.1.1 - 192.168.1.14|.
To prove that my program works I will screenshot the output when run with the
stated parameters and I will use a website to translate the same subnet and show
that it displays the same addresses as my program.
In figure~\ref{cidrtest} you can see that the output from my program matches
the expected list of IP addresses from \verb|192.168.1.1| to \verb|192.168.1.14|
which is also shown by the screen shot of the same subnet translated by
the ipcalc utility on linux.
This proves my program works and covers success criteria~\ref{cidr}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{iplist.png}
  \caption{%
    Screenshot showing the output of my program when asked to translate the subnet 192.168.1.0/28.
  }\label{cidrtest}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{ipcalclist.png}
  \caption{%
    Screenshot showing the range displayed by the ipcalc utility when asked to calculate
    the same subnet.
  }\label{cidrwebproof}
\end{figure}

\subsubsection{Scanning without first checking whether hosts are up.}
To show this I will perform a TCP scan on a small subnet where I
know there are no hosts and show that the scan continues despite there actually
being no host on the other end. To do this I will pass the \verb|-Pn| flag
and I will specify the subnet \verb|192.168.43.0/28| which I know has no has no hosts
on it. I will also specify \verb|-p 12345| to only scan port 12345 so that there are
fewer requests in the packet capture. Finally I will specify \verb|-sS| to do \gls{tcp}
SYN SCANNING.\@ I expect to see a multiple of 14 \gls{arp} messages.
This is because I don't know how many times my \gls{nic} will retry at getting
the destination \gls{mac} address. It needs to destination \gls{mac} address to send
the packet to its destination as we are scanning a private IP range of my router.
In figure~\ref{nocheckoutput} you can see the output of my program when run with the
specified flags, you can see that as expected it showed that there were no open ports
on those machines as they don't exist. In figure~\ref{nocheckwireshark} you can see the
packet capture of the packets my code sent, however there are only ARP messages, this is
because we are scanning in the private IP range of my router which was the only
way I could guarantee that there was no machine at the other end. However this is
as expected, as well as this we can see 42 \gls{arp} requests, which is $3\times14$
\gls{arp} requests, which would indicate each scan made three \gls{arp} requests before
giving up. This shows my program can perform scans without first checking if the host is
up, showing success criteria~\ref{nocheck}.
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{nocheckhostoutput.png}
  \caption{%
    Screenshot showing the output from my code when asked to port scan a subnet
    with no machines behind the addresses.
  }\label{nocheckoutput}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{nocheckpcap.png}
  \caption{%
    Screenshot showing the ARP requests my NIC sent to attempt to determine
    where to send the attempted connection packets.
  }\label{nocheckwireshark}
\end{figure}

\subsubsection{Detecting whether a TCP port is open}
To show this I will perform a \gls{tcp} \verb|Connect()| scan on my local
machine while running a script which will listen on port 12345 for any connections
and send back a message. To do this I will pass my program the flags \verb|-sT| and
\verb|-p 12345| as well as specifying localhost to scan (127.0.0.1).
I expect to see a \gls{tcp} SYN-ACK handshake between my program and the script and
then my program to output that the port is open. In figure~\ref{tcpopenpcap} you can
see the expected \gls{tcp} SYN-ACK handshake performed by my program and the script
in figure~\ref{tcpopenscript}.
You can see the output of my program in figure~\ref{tcpopenoutput}, as expected
it outputs that port 12345 is open. This shows success criteria~\ref{blackbox}
and~\ref{tcpopen}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{tcpopenscript.png}
  \caption{%
    Screenshot showing the script I ran to accept a connection on localhost port 12345.
  }\label{tcpopenscript}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{tcpopenoutput.png}
  \caption{%
    Screenshot showing the output of my script when run with the specified flags
    and while the script in figure~\ref{tcpopenscript} was running.
  }\label{tcpopenoutput}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{tcpopenpcap.png}
  \caption{%
    Screenshot showing the packet capture of the TCP SYN-ACK handshake performed
    by the scan in figure~\ref{tcpopenoutput} with the script in~\ref{tcpopenscript}.
  }\label{tcpopenpcap}
\end{figure}

\subsubsection{Detecting whether a TCP port is closed}
To show this I will perform a \gls{tcp} \verb|Connect()| scan
on my local machine except instead of running a script to catch the
request I will just let it try to connect to the closed port.
I expect to see a \gls{tcp} SYN packet sent to the port and then a RST, ACK
packet sent back, my program should output no open ports.
To do this I will pass my program the same options as in the test for
a \gls{tcp} open port.
In figure~\ref{tcpclosedpcap} you can see the attempted connection to
127.0.0.1 port 12345 along with the RST, ACK packet afterwards indicating
the port is closed. This is reflected in figure~\ref{tcpclosedoutput}
with no open ports showing success criteria~\ref{blackbox} and~\ref{tcpclosed}.
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{tcpclosedoutput.png}
  \caption{%
    Screenshot showing the output of my program when run with the specified options.
  }\label{tcpclosedoutput}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{tcpclosedpcap.png}
  \caption{%
    Screenshot showing the packet capture of the TCP SYN-RST closed port indication
    caused by the scan in figure~\ref{tcpclosedoutput}.
  }\label{tcpclosedpcap}
\end{figure}

\subsubsection{Detecting whether a TCP port is filtered}
To show this I will perform a \gls{tcp} SYN scan on localhost port 12345
except I will also introduce a firewall rule to drop all requests to localhost.
I expect this to produce no response to the initial SYN packet sent by my
program and my program to output that port as filtered. To test this I will
run my program with the flags \verb|-sS,-p 12345,-Pn| this will cause it to not
check whether the host is up, to perform a \gls{tcp} SYN scan and only scan port 12345.
I will also introduce a firewall rule using the linux iptables utility to drop
all requests to localhost as so: \verb|iptables -I INPUT -s 127.0.0.1 -j DROP|.
The output of my program is shown in figure~\ref{tcpfilteredoutput} you can
see that port 12345 is displayed as filtered and in the packet capture shown in
figure~\ref{tcpfilteredpcap} you can see that there is no response to our initial packet
which corresponds to what I thought would happen with an iptables rule in place
to drop packets. This shows success criteria~\ref{blackbox} and~\ref{tcpfiltered}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{tcpfilteredoutput.png}
  \caption{%
    Screenshot showing the output of my program when run with the specified options
    and a firewall in place to drop all packets to 127.0.0.1.
  }\label{tcpfilteredoutput}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{tcpfilteredpcap.png}
  \caption{%
    Screenshot showing the packet capture of the scan in figure~\ref{tcpfilteredoutput}
  }\label{tcpfilteredpcap}
\end{figure}

\subsubsection{Detecting whether a UDP port is open}
To show this I will perform a \gls{udp} scan on a script I have already written while
developing \gls{udp} scanning which can be seen in listing~\ref{udpopenscript}.
I expect to see my program output port 12345 as open and in the packet capture I
expect to see two \gls{udp} packets followed by two response \gls{udp} packets from my
listener program. I will test this using the following flags: \verb|-Pn,-p 12345,-sU|
these translate to scanning port 12345 over UDP and not checking the host is up beforehand.
In figure~\ref{udpopenoutput} you can see the output of my program when run as specified
and you can see that it correctly detects port 12345 as being open.
In figure~\ref{udpopenpcap} you can see the packet capture of my program being run
however this is not as I expected, I didn't foresee the \gls{icmp} destination unreachable
messages, these are sent by the kernel in response to the UDP probe which it doesn't know what
to do with, however apart from those the capture shows everything as expected.
This shows success criteria~\ref{blackbox} and~\ref{udpopen}.

\lstinputlisting[firstline=3,caption=Script to open port 12345 to UDP.,label=udpopenscript]{../../Code/udp_scan/open_X_port_to_UDP.py}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{udpopenoutput.png}
  \caption{%
    Screenshot showing the output of my program when run with the options specified
    above, and the script in listing~\ref{udpopenscript} is running.
  }\label{udpopenoutput}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{udpopenpcap.png}
  \caption{%
    screenshot showing the packet capture of the scan in figure~\ref{udpopenoutput}
  }\label{udpopenpcap}
\end{figure}

\subsubsection{Detecting whether a UDP port is closed}
To show this I will perform a \gls{udp} scan on a port which
has no service listening behind it. I expect my program to print out
no filtered ports and no open ports showing that the port was closed.
In the packet capture I expect to see three \gls{udp} packets and three response
\gls{icmp} packets. To test this I will use my program with the following flags:
\verb|-p 12345,-Pn,-sU| which perform a \gls{udp} port scan without first checking
if the host is up. In figure~\ref{udpclosedoutput} you can see the output of my program
when run with the options specified above, you can see that there are no ports displayed
as either open or filtered, this shows the my program successfully marked the port as closed.
This shows success criteria~\ref{blackbox} and~\ref{udpclosed}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{udpclosedoutput.png}
  \caption{%
    screenshot showing the output of my program when scanning with the
    options specified above.
  }\label{udpclosedoutput}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{udpclosedpcap.png}
  \caption{%
    screenshot showing the packet capture of the scan in figure~\ref{udpclosedoutput}
  }\label{udpclosedcap}
\end{figure}

\subsubsection{Detecting whether a UDP port is filtered}
To show this I will use my program to perform a \gls{udp} scan on my local machine
with a firewall rule to drop any ports sent to the localhost address. I expect to see
my program to output the port as filtered and in the packet capture I expect to see
three \gls{udp} packets with no response to any of them.
In figure~\ref{udpfilteredoutput} you can see my program correctly identifies
the port as being filtered and in figure~\ref{udpfilteredpcap} you can see
the packet capture of the scan which also as expected shows the three \gls{udp}
packets with no reply packets. This shows success criteria~\ref{blackbox}
and~\ref{udpfiltered}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{udpfilteredoutput.png}
  \caption{%
    screenshot showing the output of my program when scanning with the
    options specified above.
  }\label{udpfilteredoutput}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{udpfilteredpcap.png}
  \caption{%
    screenshot showing the packet capture of the scan in figure~\ref{udpfilteredoutput}
  }\label{udpfilteredpcap}
\end{figure}

\subsubsection{Detecting the operating system of another machine}
I haven't directly added this as a feature to my project partly because
I didn't have time and also because it is partially achieved by version
scanning in that if a particular service is detected and that service
is OS dependent then you can be fairly certain that machine is running
that OS.\@ For example if a machine is open on \gls{tcp} port 22
and SSH is detected to be running behind that port then they are likely
to be running a linux machine. Even more likely if the scan reveals some
further information such as the \gls{cpe}. In figure~\ref{sshversiondetect}
you can see a scan of my machine where I have \gls{ssh} running,
my program reveals that the version is 7.9 and the vendor is openbsd
which is a unix like operating system, this shows that my ssh version
is unix based and therefore I am likely to be running on linux, which is
the case. So although it is not directly a feature in a round a bout way.
This partially completes success criteria~\ref{osdetect}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{sshversiondetect.png}
  \caption{%
    screenshot showing a version scan of my local machine.
  }\label{sshversiondetect}
\end{figure}

\subsubsection{Detecting the service and its version running behind a port}
To show this I will use my program to perform a version detection scan on my local machine
while I am running \gls{ssh}. I expect to see my program identify that \gls{ssh} is running
on \gls{tcp} port 22 and that it detects it as OpenSSH version 7.9. To test this
I will run my program with the \verb|-sV| flag to indicate version detection and
I will run it against the localhost address. In figure~\ref{versiondetect}
you can see that my program successfully identified \gls{ssh} as running on
\gls{tcp} port 22 as well as the expected identification of OpenSSH version 7.9
operating on protocol version 2.
It also identified some CPE information such as OpenSSH coming from the openbsd
distribution.
This shows success criteria~\ref{blackbox},~\ref{servicedetect} and~\ref{versiondetect}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{sshversiondetect.png}
  \caption{%
    screenshot showing a version scan of my local machine running ssh.
  }\label{versiondetecttest}
\end{figure}

\subsection{Test Table}
\newcounter{row number}
\newcommand\rownumber{\stepcounter{row number}\arabic{row number}}
\begin{center}
  \begin{tabular}{r l l l r r}
    \toprule
    Test No.   & Test Data   & Expectation & Result & Fig & Success Criteria \\
    \midrule
    \rownumber{} & & usage message & Pass &\ref{noparametertest} &\ref{usage}  \\
    \rownumber{} & \verb| -h| & help message & Pass &\ref{hflagtest} &\ref{usage}  \\
    \rownumber{} & \verb|--help| & help message & Pass &\ref{helpflagtest} &\ref{usage}  \\
    \rownumber{} & \verb| -sL| & print addresses & Pass &\ref{cidrtest} &\ref{cidr}  \\
    \rownumber{} & \verb| -sn| & ping scan & Pass &\ref{lanscantest} &\ref{ping}  \\
    \rownumber{} & \verb| -Pn| & assume host up& Pass &\ref{nocheckoutput} &\ref{nocheck}  \\
    \rownumber{} & \verb% -sS|sT% & TCP port open& Pass &\ref{tcpopenoutput} &\ref{tcpopen}  \\
    \rownumber{} & \verb% -sS|sT% & TCP port closed& Pass &\ref{tcpclosedoutput} &\ref{tcpclosed}  \\
    \rownumber{} & \verb| -sS| & TCP port filtered& Pass &\ref{tcpfilteredoutput} &\ref{tcpfiltered}  \\
    \rownumber{} & \verb| -sU| & UDP port open& Pass &\ref{udpopenoutput} &\ref{udpopen}  \\
    \rownumber{} & \verb| -sU| & UDP port closed& Pass &\ref{udpclosedoutput} &\ref{udpclosed}  \\
    \rownumber{} & \verb| -sU| & UDP port filtered& Pass &\ref{udpfilteredoutput} &\ref{udpfiltered}  \\
    \rownumber{} & \verb| -sV| & OS detection & Partial &\ref{sshversiondetect} &\ref{osdetect}  \\
    \rownumber{} & \verb| -sV| & service detection & Pass &\ref{sshversiondetect} &\ref{servicedetect}  \\
    \rownumber{} & \verb| -sV| & version detection & Pass &\ref{sshversiondetect} &\ref{versiondetect}  \\
    \bottomrule
  \end{tabular}
\end{center}

\section{Evaluation}

\subsection{Reflection on final outcome}

\subsection{Evaluation against objectives, end user feedback}

\subsection{Potential improvements}

\appendix

\section{Technical Solution}\label{code}
\lstset{language=python}
\subsection{icmp\_ping}\label{app:icmpping}
\lstinputlisting[caption=A prototype program for sending ICMP ECHO REQEST packets,label=icmpechosend]{../../Code/icmp_ping/icmp_echo_send.py}
\lstinputlisting[caption=A prototype program for receiving ICMP ECHO REQEST packets,label=icmpechorecv]{../../Code/icmp_ping/icmp_echo_recv.py}

\subsection{ping\_scanner}\label{app:pingscanner}
\lstinputlisting[caption=A prototype program for performing `ping' scans,label=pingscanner]{../../Code/ping_scanner/ping_scan.py}

\subsection{subnet\_to\_addresses}\label{app:subnettoaddresses}
\lstinputlisting[caption=A program which translates a CIDR specified subnet into a list of addresses and prints them out in sorted order,label=subnettoaddresses]{../../Code/subnet_to_address.py}

\subsection{tcp\_scan}\label{app:tcpscan}
\subsubsection{connect\_scan}\label{app:connectscan}
\lstinputlisting[caption=prototype TCP connect scanner only attempting to detect the state of port 22,label=connectsshattempt]{../../Code/tcp_scan/connect_scan/ssh_attempt.py}
\lstinputlisting[caption=A program that performs TCP connect scanning, label=connectscanportlist]{../../Code/tcp_scan/connect_scan/scan_port_list.py}

\subsubsection{syn\_scan}\label{app:synscan}
\lstinputlisting[caption=A prototype program that tries to detect the state of port 22 via TCP SYN scanning (aka half open scanning),label=synsshattempt]{../../Code/tcp_scan/syn_scan/ssh_attempt.py}
\lstinputlisting[caption=A program that performs TCP SYN scanning (aka half open scanning),label=synscanportlist]{../../Code/tcp_scan/syn_scan/scan_port_list.py}

\subsection{udp\_scan}\label{app:udpscan}
\lstinputlisting[caption=A prototype program to detect whether UDP port 53 is open on a target machine, label=dnsattempt]{../../Code/udp_scan/dns_attempt.py}
\lstinputlisting[caption=A program for performing scans on UDP ports.,label=udpscanportlist]{../../Code/udp_scan/scan_port_list.py}
\lstinputlisting[caption=A program I made to open a port via UDP for testing my UDP scanner.,label=openxport]{../../Code/udp_scan/open_X_port_to_UDP.py}

\subsection{version\_detection}\label{app:versiondetection}
\lstinputlisting[caption=A program which does version detection on services.,label=versiondetection]{../../Code/version_detection/version_detection.py}

\subsection{modules}\label{app:modules}
\lstinputlisting[caption=A python module I wrote for parsing and holding the version detection probes from the nmap\_service\_probes file.,label=directives]{../../Code/modules/directives.py}
\lstinputlisting[caption=A python module I made to dissect and hold protocol headers.,label=headers]{../../Code/modules/headers.py}
\lstinputlisting[caption=A python module I wrote to contain lots of useful functions which I found I was declaring in multiple places and makign changes so I decided to keep an up to date central one.,label=iputils]{../../Code/modules/ip_utils.py}
\lstinputlisting[caption=A python module I made to hold all of the listeners I had made for each of the different scanning types.,label=listeners]{../../Code/modules/listeners.py}
\lstinputlisting[caption=A python module I made to hold all of the scanners I had made for each of the different scanning types.,label=scanners]{../../Code/modules/scanners.py}

\subsection{examples}\label{app:examples}
\lstinputlisting[caption=A program I wrote to run all of the example scripts I made from one main script to solve the issue of the PATH being used for determining import when I could use Pythons built in module structure instead.,label=runexamples]{../../Code/run_examples.py}

\subsection{netscan}\label{app:netscan}
\lstinputlisting[caption=The program which provides the command line user interface for my projects functionality.,label=netscan]{../../Code/netscan.py}

\subsection{tests}\label{app:tests}
\lstinputlisting[caption=Unit tests I wrote for the ip\_utils module.,label=testiputils]{../../Code/tests/test_ip_utils.py}
\lstinputlisting[caption=Unit tests I wrote for the directives module.,label=testdirectives]{../../Code/tests/test_directives.py}

\clearpage
\bibliographystyle{plain}
\nocite{*}
\bibliography{bibliography}


\clearpage
\printnoidxglossaries{}

\end{document}
