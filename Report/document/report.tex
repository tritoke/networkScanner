\documentclass[titlepage]{article}

\usepackage{graphicx} % for embedding pictures
\usepackage{wrapfig} % for use with figures
\usepackage[hidelinks]{hyperref} % allows embedding links
\usepackage[dvipsnames]{xcolor} % gives me some colours by name
\usepackage[T1]{fontenc} % fixes weird font size/encoding issues
\usepackage{listings} % used to format code
\usepackage{algorithm} % used with the below package to format psuedo code
\usepackage[noend]{algpseudocode}
\usepackage{mathtools} % used for all the mathematical notation
\usepackage{etaremune} % enumerate backwards for OSI model
\usepackage{placeins} % used to ensure everything stays inside where it is 
% defined, i.e. subsections jumping above figures etc.
\usepackage[nopostdot]{glossaries} % guess what. It manages glossaries
\setacronymstyle{long-short}
\makenoidxglossaries{}

\loadglsentries{glossary}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

% code formatting options
\lstset{%
  frame=tb,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true
}


% forces [sub]sections to contain everything that is defined before the next one
\let\Oldsection\section{}
\renewcommand{\section}{\FloatBarrier\Oldsection}

\let\Oldsubsection\subsection{}
\renewcommand{\subsection}{\FloatBarrier\Oldsubsection}

\let\Oldsubsubsection\subsubsection{}
\renewcommand{\subsubsection}{\FloatBarrier\Oldsubsubsection}


% title
\author{Sam Leonard}
\title{A Level Computer Science Non-Examined Assessment (NEA)}
\date{} % this forces no date to be shown


\begin{document}

\maketitle

\tableofcontents

\section{Analysis}

\subsection{Identification and Background to the Problem}

The problem I am trying to solve with my project is how to look at devices on a network
from a ``\gls{bbox}'' perspective and gain information about what \glspl{service} are running etc.
Services are programs which their entire purpose is to provide a \textit{\gls{service}} to other
programs, for example a server hosting a website would be running a \gls{service} whose purpose
is to send the webpage to people who try to connect to the website. \\
There are many steps in-between a device turning on to interacting with the internet.

\begin{enumerate}
  \item{load networking \glspl{driver}}
  \item{Starting \gls{dhcp} \gls{daemon}}
  \item{Broadcasting \gls{dhcp} request for an \gls{ipaddr}}
  \item{Get assigned an \gls{ipaddr}}
  \item{???}
  \item{Profit!!!}
\end{enumerate}

There are many more steps than I have listed above. Starting from a linux computer being switched on
the first step is that the \gls{kernel} needs to load the networking \glspl{driver}. The \gls{kernel} is the basis for the
operating system, it is what interacts with the hardware in the most fundamental way. \glspl{driver} are small
bits of code which the \gls{kernel} can load in order to interact with certain hardware modules such as the
\gls{nic} which is essential for interfacing with the network, hence the name.

Next once the \gls{kernel} has loaded the required \glspl{driver} and the system has booted the networking
`\glspl{daemon}' must be started. In linux a \gls{daemon} is a program that runs all the time in the background
to serve a specific purpose or utility. For example when I start my laptop the following \glspl{daemon} start
\gls{upow} (power management), \gls{sysd} (manages the creation of all processes), \gls{dbus} (manages
inter-process communication), iwd (manages my WiFi connections) and finally \gls{dhcpcd} which manages all
interactions with the network around \gls{dhcp}.

Once the \glspl{daemon} are all started the \gls{dhcp} client sends a discover message with the address
255.255.255.255 which is the IP limited broadcast address which means that whatever is listening at the
other end will forward this \gls{pkt} on to everyone on the \gls{subnet}. When the \gls{dhcp} \gls{server} on the subnet
receives this message it reserves a free \gls{ipaddr} for that client and then responds with a \gls{dhcp} offer
which contains the address the \gls{server} is offering, the length of time the address is valid for and the
\gls{subnet} mask of the network. The client must then respond with a \gls{dhcp} request message to request the
offered address, this is in case of multiple DHCP servers offering addresses. Finally the \gls{dhcp} server responds
with a \gls{dhcp} acknowledge message showing that it has received the request. Figure~\ref{dhcp_negotiate} shows
a \gls{pkt} capture from my laptop where I turned WiFi off, started wireshark listening and plugged in an Ethernet
cable, I have it showing only the \gls{dhcp} \glspl{pkt} so that it is clear to see the entire \gls{dhcp} negotiation
including the 255.255.255.255 limited broadcast destination address and the 0.0.0.0 unassigned address in the source
column.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{screenshots/dhcp_negotiation.png}
  \caption{\gls{dhcp} address negotiation}\label{dhcp_negotiate}
\end{figure}

All computer networking is encapsulated in the \gls{osi} which has 7 layers:

\begin{etaremune}
  \item{Application: \gls{api}s, \gls{http}, \gls{ftp} among others.}
  \item{Presentation: encryption/decryption, encoding/decoding, decompression etc\ldots}
  \item{Session: Managing sessions, \gls{php} session IDs etc\ldots}
  \item{Transport: TCP and UDP among others.}
  \item{Network: ICMP and IP among others.}
  \item{Data Link: MAC addressing, Ethernet protocol etc\ldots}
  \item{Physical: The physical Ethernet cabling/\gls{nic}.}
\end{etaremune}

Each of these layers is essential to the running of the internet but a single communication
might not include all of the layers.

These communications are all based on the most fundamental part of the internet: the \gls{pkt}.
Packets are sequences of ones and zeros sent between computers which are used to transfer
data as well as to control how networks function. They consist of different layers of 
information each specifying where the \gls{pkt} where should go next at a different level
along with fundamentally the data/instructions contained in the innermost layer. When \glspl{pkt}
are sent between computers a certain number of layers are stripped off by each computer so
that it knows where to send the \gls{pkt} next at which point it will add all the layers back
again, this time with the instructions needed to go from the current computer to the next
one on its route. Each of these layers actually consists of a number of fields at the start
called a \gls{header} some layers also append a footer to the end of the packet. The actual
data being transferred in the packet can be quite literally anything, \gls{http} transfers
websites so \gls{html} files and images etc\ldots

I'm going to use the example of getting a very
simple static HTML page with an image inside. The code for the page is shown in
listing~\ref{examplepage}. In figure~\ref{basicwebpage} you can see how the page renders.
However far more interestingly is how the browser retrieved the page, in figure~\ref{getrequest}
you can see the full sequence of \glspl{pkt} that were exchanged for the browser to get the resources
it needed to render the page. I am hosting the page using python3's http.server module
which is super convenient and just makes the current directory open on port 8000
from there I can just navigate to /example.html and it will render the page. Breaking
figure~\ref{getrequest} down \gls{pkt} one shows the browser receiving the request from
the user to display \verb|http://192.168.1.47:8000/example.html| and attempting to connect
to 192.168.1.47 on port 8000. Packets two and three show the negotiation of this request
through to the full connection being made. The browser now makes an \gls{http} GET
request for the page example.html over the established TCP connection as shown in \gls{pkt} 4.
The server then acknowledges the request and sends a \gls{pkt} with the PSH flag set
as shown in \glspl{pkt} 6 and 7. The PSH flag is a request to the browser to say that it is
OK to received the buffered data, i.e.\ example.html. The browser then sends back an
acknowledgement and the server sends the page as shown in \glspl{pkt} 7 and 8. Finally
the browser sends a final acknowledgement of having received the page before initiating
a graceful session teardown by sending a FIN ACK \gls{pkt} which indicates the end of a session.
Once the server responds to the FIN ACK with it's own the browser sends a final acknowledgement.
This then repeats itself when the browser parses the HTML and realises theres an image which
it needs to get from the server as well, except the image is a larger file and so takes a few
more PSH \glspl{pkt}.

This shows clearly the interaction between each of the different layers in the OSI model,
the browser at level 7: Application rendering the webpage. Level 6: Presentation is skipped as
we have no files which need to be served compressed because they are so large. Level 5: Session
is shown by the TCP session negotiation and graceful teardown of the TCP session. Level 4: Transport
is shown when the image and webpage are transferred from the server to the browser. Level 3/2/1
are shown in figure~\ref{deconstructed} where you can see the IP layer information along with
Ethernet II and finally frame 4 which is the bytes that went down the wire.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{screenshots/basic_webpage.png}
  \caption{%
    A basic static \gls{html} webpage.
  }\label{basicwebpage}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{screenshots/website_get.png}
  \caption{%
    A full chain of \glspl{pkt} that shows retrieving a basic webpage
    from the server.
  }\label{getrequest}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{screenshots/website_get_ladder.png}
  \caption{%
    Ladder diagram of figure~\ref{getrequest}.
  }\label{getrequestladder}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{screenshots/deconstructed_packet.png}
  \caption{%
    A look inside a TCP \gls{pkt}.
  }\label{deconstructed}
\end{figure}

\lstset{language=HTML}
\lstinputlisting[caption={example.html}, label={examplepage}]{../example.html}

\subsection{Analysis of problem}

The problem with looking at a network from the outside is that the purpose of the network is to
allow communication inside of the network, thus very little is exposed externally. This presents
a challenge as we want to know what is on the network as well as what each of them is running which
is not always possible due to the limited information that \glspl{service} will reveal about themselves.
Firewalls also play large part in making scanning networks difficult as sometimes they simply drop
\glspl{pkt} instead of sending a \gls{tcp} RST \gls{pkt} (reset connection \gls{pkt}).
When firewalls drop \glspl{pkt} it becomes exponentially more difficult as you don't know whether
your \gls{pkt} was corrupted or lost in transit or if it was just dropped. \\\\
To demonstrate this I will show three things:

\begin{enumerate}
  \item{A successful connection over \gls{tcp}.}
  \item{An attempted connection to a closed port.}
  \item{An attempted connection with a firewall rule to drop packets.}
\end{enumerate}
Firstly A successful \gls{tcp} connection. For a \gls{tcp} connection to be established there
is a three way handshake between the communicating machines. Firstly the machine trying to
establish the connection sends a \gls{tcp} SYN packet to the other machine, this packet
holds a dual purpose, to ask for a connection and if it is accepted to SYNchronise the sequence
numbers being used to detect whether packets have been lost in transport. The receiving machine
then replies with a \gls{tcp} SYN ACK which confirms the starting sequence number with the SYN part
and ACKnowledges the connection request. The sending machine then acknowledges this by sending a
final \gls{tcp} ACK packet back. This connection initialisation is shown in figure~\ref{data_transfer}
by packets one, two and three. Data transfer can then commence by sending a \gls{tcp} packet with
the PSH and ACK flags set along with the data in the data portion of the packet, this is shown
in figure~\ref{data} where wireshark allows us to take a look inside the packet to see the data being
sent in the packet along with the PSH and ACK flags being set. The code I used to generate these
is shown in figures~\ref{sender} and~\ref{receiver}. Breaking the code down in figure~\ref{receiver}
you can see me initialising a socket object then I bind it to localhost (127.0.0.1) port 12345
localhost is just an address which allows connections between programs running on the same computer
as connections are looped back onto the current machine, hence its alternative name: the loopback
address. I then tell it to listen for incoming connections, the one just means how many connections
to keep as a backlog. I then accept the connection from the program in figure~\ref{sender}, line 3.
I then tell the program to listen for up to 1024 bytes in the data part of any TCP packets sent.
The program in figure~\ref{sender} then sends some data which we then see printed to the screen
in figure~\ref{receiver}, both programs then close the connection.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{screenshots/data_transfer.png}
  \caption{%
    Packets starting a TCP session, transferring some data then ending it.
  }\label{data_transfer}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{screenshots/sender.png}
  \caption{%
    Transferring some basic text data over a TCP connection.
  }\label{sender}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{screenshots/receiver.png}
  \caption{%
    Receiving some basic text data over a TCP connection.
  }\label{receiver}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{screenshots/data.png}
  \caption{%
    Highlighted packet carrying the data being transferred in figure~\ref{sender}.
  }\label{data}
\end{figure}

Next an attempted connection to a closed port. In figure~\ref{firewall} packet one you can see
the same \gls{tcp} SYN packet as we saw in the attempted connection to an open port, as you
would expect. The difference comes in the next packet with the \gls{tcp} RST flag being sent
back. This flag means to reset the connection, or if the connection is not yet established
as in this case it means that the port is closed, hence why the packet is highlighted red
in figure~\ref{firewall}. The code used to generate this is shown in figure~\ref{firewall_code}
line two shows the initialisation of a socket object. In line 3 the program tries to connect
to port 12345 on localhost again, except this time we get a connection refused error back
this shows us that the remote host sent a \gls{tcp} RST packet back, which is reflected in
figure~\ref{firewall}.

Finally I will show a connection where the firewall is configured to drop the packet. However first
I will explain a bit about firewalls and how they work. Firewalls are essentially the gatekeepers
of the internet they decide whether a packet gets to pass or whether they shall not pass. Firewalls
work by a set of rules which decide what happens to it. A rule might be that it is coming from a certain
\gls{ipaddr} or has a certain destination port. The actions taken after the packet has had it's fate
decided by the rules can be one of the following three (on iptables on linux): ACCEPT, DROP and RETURN,
accept does exactly what you think it would an lets the packet through, drop quite literally just drops
the packet and sends no reply whatsoever, return is more complicated and has no effect on how port
scanning is done and as such we will ignore it. A common set of rules for something like a webserver
would be to DROP all incoming packets and then allow exceptions for certain ports i.e.\ port 80 for
\gls{http} or 443 for \gls{https}. I will be using a linux utility called iptables for implementing
all firewall rules on my system for demonstration purposes. Packet number three in
figure~\ref{firewall} shows the connection request from line 4 of~\ref{firewall_code} except
that I have enabled a firewall rule to drop all \glspl{pkt} from the address 127.0.0.1, using
the iptables command as so: \verb$iptables -I INPUT -s 127.0.0.1 -j DROP$. This command reads
as for all \glspl{pkt} arriving (\verb|-I INPUT|) with source address 127.0.0.1 (\verb|-s 127.0.0.1|)
drop them sending no response (\verb|-j DROP|). With this firewall rule in place you can see in
figure~\ref{firewall} \gls{pkt} 3 receives no response and as such python assumes that the \gls{pkt}
just got lost and as such tries to send the \gls{pkt} again repeatedly, this continued for more than
30 seconds before a stopped it as shown by the time column in figure~\ref{firewall} and the final
\verb|KeyboardInterrupt| in figure~\ref{firewall_code}. The amount of time that a system will wait
still trying to reconnect depends on the OS and a other factors but the minimum time is 100 seconds
as specified by RFC 1122, on most systems it will be between 13 and 30 minutes according the
linux manual page on \gls{tcp}.
\begin{verbatim}
man 7 tcp:
tcp_retries2 (integer; default: 15; since Linux 2.2)
  The maximum number of times a TCP packet is retransmitted in
  established state before giving up. The default value is 15,
  which corresponds to a duration of approximately between 13 to 30
  minutes, depending on the retransmission timeout. The RFC 1122
  specified minimum limit of 100 seconds is typically deemed too short.
\end{verbatim}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{screenshots/packet_drop.png}
  \caption{%
    Attempted connection to a closed port with and without firewall rule to drop \glspl{pkt}.
  }\label{firewall}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{screenshots/packet_drop_code.png}
  \caption{%
    The code used to produce firewall \gls{pkt} dropping example in figure~\ref{firewall}
  }\label{firewall_code}
\end{figure}

\subsection{Numbered List of Objectives (also called Success Criteria, the end user requirements)}

\begin{enumerate}
\item{Show a basic usage message when called with no arguments.}
\item{Show a help message when called with \texttt{--help} or \texttt{-h}.}
\item{Scan the 1000 most commonly used \gls{tcp} \glspl{port} when called with just an \gls{ipaddr}.}
\item{Scan the \glspl{port} specified by \texttt{-p <ports>} or \texttt{--ports <ports>}.}
\item{Parse either a comma separated list of \glspl{port} e.g.\ \texttt{1,2,3,4} or a range specified set of \glspl{port} e.g.
  \texttt{1{\textendash}4}}.
\item{Scan all \glspl{port} in each scan type when called with \texttt{-p-}.}
\item{Don't scan the \glspl{port} specified by \texttt{--exclude-ports <ports>} in any scan.}
\item{Expand a \gls{cidr} specified \gls{subnet} when used in the target specification.}
\item{List all of the \gls{ipaddr}es that would be scanned when given the \texttt{-sL} flag.}
\item{Only ping each specified address when supplied the \texttt{-sn} flag.}
\item{When doing a ping scan (\texttt{-sn}) display the Time To Live (TTL) and latency of each host.}
\item{Don't ping each of the hosts before scanning to check if they are up when supplied with the \texttt{-Pn} flag.}
\item{Perform a \gls{tcp}SYN scan on the 1000 most common \gls{tcp} \glspl{port} on each target specified when given the \texttt{-sS} flag.}
\item{Perform a \gls{tcp} \verb|Connect()| scan on the 1000 most common \gls{tcp} \glspl{port} on each target specified when given the \texttt{-sT} flag.}
\item{Perform a\gls{udp}scan on the 1000 most common\gls{udp} \glspl{port} when on each target specified when given the \texttt{-sU} flag.}
\item{Perform version detection on the \glspl{service} running on each of the hosts specific when given the \texttt{-sV} flag.}
\end{enumerate}

\subsection{Description of current system or existing solutions}

Nmap is currently the most popular tool for doing\gls{port}scanning and host enumeration.
It supports the following scanning types:

\begin{itemize}
\item{\gls{tcp}:\ SYN}
\item{\gls{tcp}:\ \verb|Connect()|}
\item{\gls{tcp}:\ ACK}
\item{\gls{tcp}:\ Window}
\item{\gls{tcp}:\ Maimon}
\item{\gls{tcp}:\ Null}
\item{\gls{tcp}:\ FIN}
\item{\gls{tcp}:\ Xmas}
\item{\gls{udp}}
\item{Zombie host/idle}
\item{\gls{sctp}:\ INIT}
\item{\gls{sctp}:\ COOKIE-ECHO}
\item{IP protocol scan}
\item{\gls{ftp}:\ bounce scan}
\end{itemize}

As well as supporting a vast array of scanning types it also can do \gls{service} version detection
and operating system detection via custom probes. Nmap also has script scanning which allows
the user to write a script specifying exactly how they want to scan e.g.\ to circumvent \gls{port knocking}
(where \glspl{pkt} must be sent to a sequence of \glspl{port} in order before access to the final\gls{port}is allowed).
It also supports a plethora of options to avoid firewalls or \gls{ids} such as sending
\glspl{pkt} with spoofed \glspl{csum}/source addresses and sending decoy probes. Nmap can do many more things than I
have listed above as is illustrated quite clearly by the fact there is an entire working on using nmap
(\href{https://nmap.org/book/}{https://nmap.org/book/})

\subsection{Prospective Users}

The prospective users of this system would be system administrators, penetration testers or network engineers.
In my case my prospective users would be my school's system administrators and it would allow them to see an
outsiders perspective on for example the \gls{server} running the school's website page or to see if any of the
programs on the \glspl{server} were leaking information through \glspl{banner} etc. (most \glspl{service} send a \gls{banner} with
information like what protocol version they use and other information)

\subsection{Data Dictionary}

\textbf{\color{red}{I looked this up and it seemed to be related to database management systems.}}

\href{https://en.wikipedia.org/wiki/Data_dictionary}{https://en.wikipedia.org/wiki/Data\_dictionary}

\subsection{Data Flow Diagram}

\textbf{\color{red}{This seems to be fairly relevant and to do with how data goes through my program
    i.e.\ going from the network to my port scanner into a target object and other scanners
before version detection and finally displaying to the user. Make a flowchart for this.}}

\href{https://en.wikipedia.org/wiki/Data-flow_diagram<Paste>}{https://en.wikipedia.org/wiki/Data-flow\_diagram}

\subsection{Data Sources}

\textbf{\color{red}{Not really sure about this.}}

\subsection{Description of Solution Details, OOP/Mobile/Networking}

To do all forms of scanning other than \verb|Connect()| scanning and version detection, custom
\glspl{pkt} are made to allow the \gls{half open} (no full connection is made to the host) scanning
used in\gls{tcp}SYN scanning. Making custom \glspl{pkt} is quite difficult because the endianness
(the order the bytes are interpreted in: big endian, most significant byte first, little endian,
least significant byte first) affects how all the information packed into the \gls{pkt} is interpreted
by the network switch, for example the\gls{ipaddr}192.168.1.58 packed in big endian form but interpreted
being in little endian form comes out as 58.1.168.192 which is a completely different address and
will mean the \gls{pkt} is not routed to the correct host. As well as the issues with byte order
and the interpretation of information at different points the \gls{csum} which is embedded into
the \gls{pkt} is calculated from a psuedo-header calculated from information in the underlying
IP \gls{header} and all of this has to be calculated in the right byte order (endianness).

I have used Python's multiprocessing module to allow me to spawn another process which listens
for responses from hosts and waits for a certain amount of time before returning information
on what hosts responded and in the case of ping scanning also metadata about how they responded.

In version detection scanning the relationship between the data sources and modules used is quite
complex so I have used an \gls{oop} approach to group the methods
that act on the data along with the data itself. For example each probe defined in the \verb|nmap-service-probes|
file can be sent to a host and matched against a list of match directives stored in the probe,
the probe class has a scan method which sends it's probe to the host and then automatically runs
match and soft-match directives against the information returned by the probe.

Parsing the match and softmatch directives was quite difficult because they include regular
expressions with special characters such as newlines and carriage returns in the form of
\verb|\n| and \verb|\r| characters which python escapes to \verb|\\n|
and \verb|\\r|. Which instead of matching a newline character and a carriage return
will match a literal backslash and then an n or an r which is not what we want. To fix this I have to substitute
newline and carriage returns back in where I find \verb|\\r| and \verb|\\r|.

\subsection{Acceptable Limitations (Supplementary)}

Originally I had planned to include dedicated operating system detection as an option
however I ran out of time having implemented version detection. However it still does
Operating system detection partially as some \glspl{service} are linux only and while doing
\gls{service} and version detection especially the \gls{cpe} parts
of the matched \gls{service}/version will contain operating system information, such as
microsoft ActiveSync would indicate that the system being scanned was a windows system
which is reflected in the match directive and attached CPE information: \texttt{%
match activesync m|{\textasciicircum}.{\textbackslash}0{\textbackslash}x01{\textbackslash}0[{\textasciicircum}{\textbackslash}0]{\textbackslash}0[{\textasciicircum}{\textbackslash}0]{\textbackslash}0[{\textasciicircum}{\textbackslash}0]{\textbackslash}0[{\textasciicircum}{\textbackslash}0]{\textbackslash}0[{\textasciicircum}{\textbackslash}0]{\textbackslash}0.*{\textbackslash}0{\textbackslash}0{\textbackslash}0\$|s p/Microsoft ActiveSync/ o/Windows/ cpe:/a:microsoft:activesync/ cpe:/o:microsoft:windows/a
}


\subsection{Data Volumes (Supplementary)}

\textbf{\color{red}{This seems to be about the volume of data stored in a database.}}
\href{https://stackoverflow.com/questions/5566841/what-are-data-volumes#5567390}{https://stackoverflow.com/questions/5566841/what-are-data-volumes\#5567390}

\subsection{Test Strategy}

I am going to use two different methods to test my program:
\begin{enumerate}
\item{Unit testing}
\item{Wireshark}
\end{enumerate}
I am using two separate testing strategies because they are both good at different things,
both of which I need to show that my project works. Firstly I am using unit testing to test
some general purpose functions which are pure functions (are independent of the current state
of the machine) such as \verb|ip_range()| and other functions which I can
just check the returned value against what it should be.

Wireshark is useful for the other half of the program which uses impure functions and the
low level networking e.g.\ \verb|make_tcp_packet()|. Wireshark makes this easy by allowing capture of all
the \glspl{pkt} going over the wire, as well as this it has a vast array of \gls{pkt} decoders (2231 in my install)
which it can use to dissect almost any \gls{pkt} that would be on the network. The main
benefit of wireshark is that I can see my scanners sending \glspl{pkt} and then check whether the parsers
that I have written for the different protocols are working. I can also check that the \glspl{csum}
in each of the various protocols is valid as wireshark does \gls{csum} verification for various protocols.

\section{Design}

\subsection{Overall System Design (High Level Overview)}

There are two types of scanning implemented for different scan types in my program.
\begin{itemize}
  \item{\verb|Connect()|}
  \item{version}
  \item{listener / sender}
\end{itemize}
\verb|Connect()| scanning is the simplest in that it takes in a list of \glspl{port} and simply calls the
\verb|socket.connect()| method on it and sees whether it can connect or not and the \glspl{port} are
marked accordingly as open or closed.

Version scanning is very similar to \verb|Connect()| scanning in that it takes in a list of \glspl{port}
and connects to them, except it then sends a probe to the target to elicit a response and gain
some information about the \gls{service} running behind the \gls{port}.

Listener / sender scanning does exactly what it says on the tin: it sets up a ``listener'' in another process
to listen for responses from the host which the ``sender'' is sending \glspl{pkt} to. It can then differentiate
between open, open|filtered, filtered and closed \glspl{port} based on whether it receives a \gls{pkt} back
and what flags (part of\gls{tcp} \glspl{pkt} are a one byte long section which store ``flags'' where each bit in the
byte represents a different flag) are set in the received \gls{pkt}.

\subsection{Design of User Interfaces HCI}

I have designed my system to have a similar interface to the most common tool currently used: nmap
this is because I believe that having a familiar interface will not only make it easier for someone who
is familiar with nmap to use my tool it also makes it so that anything learnt using either tool is applicable
to both which benefits everyone.

Based on this perception I have used the same option flags as nmap as well as similar help messages
and an identical call signature (how the program is used on the command line). Running 
\verb|./netscan.py <options> <target_spec>| is identical to \verb|nmap <options> <target_spec>| in terms
of which scan types will be run, which hosts will be scanned and which \glspl{port} are scanned. Below you can see
the help message generated by \verb|./netscan.py --help|.
\begin{verbatim}
usage: netscan.py [-h] [-Pn] [-sL] [-sn] [-sS] [-sT] [-sU] [-sV] [-p PORTS]
                  [--exclude_ports EXCLUDE_PORTS]
                  target_spec

positional arguments:
  target_spec           specify what to scan, i.e. 192.168.1.0/24

optional arguments:
  -h, --help            show this help message and exit
  -Pn                   assume hosts are up
  -sL                   list targets
  -sn                   disable port scanning
  -sS                   TCP SYN scan
  -sT                   TCP connect scan
  -sU                   UDP scan
  -sV                   version scan
  -p PORTS, --ports PORTS
                        scan specified ports
  --exclude_ports EXCLUDE_PORTS
                        ports to exclude from the scan
\end{verbatim}

It shows clearly which are required arguments and which are optional ones, as well as what
each argument actually does. It also allows some some arguments to be called with either
a short format e.g.\ \verb|-p| and with a most verbose format \verb|--ports| this allows
the user to be clearer if they are using the tool as part of an automated script to perform
scanning as it is more immediately obvious what the more verbose flags do.

\subsection{System Algorithms (Flowcharts)}

\textbf{\color{Emerald}{When I have finished the first draft of the text bits I will add pictures / flowcharts}}

\subsection{Input data Validation}

My program takes very little input from the user which means that there is a very low chance of the program
crashing due to user input error as the errors are detected
All data which is entered is either parsed using a regular expression with the case of the
\glspl{port} directive (\verb|-p|) or is run through checking functions like \verb|ip_utils.is_valid_ip|.
As well as using these checking functions whenever an\gls{ipaddr}is converted between ``long form''
and ``dot form'' which is used in every type of scanning.

\subsection{Proposed Algorithms for complex structures (flow charts or Pseudo Code)}

\begin{algorithm}
  \caption{%
  My algorithm for turning a \gls{cidr} specified \gls{subnet} into a list of actual \gls{ipaddr}es
}\label{ip_range}
  \begin{algorithmic}[1]
    \Procedure{ip\_range}{}
    \State{$\textit{network\_bits} \gets \text{number of network bits specified}$}
    \State{$\textit{ip} \gets \text{base IP address}$}
    \State{$\textit{mask} \gets 0$}
    \For{$\textit{maskbit} \gets (32-\textit{network\_bits}),31$}
      \State{$\textit{mask} \gets \textit{mask} + 2^\textit{maskbit}$}
    \EndFor{}
    \State{$\textit{lower\_bound} \gets \text{\textit{ip} AND \textit{mask}}$}
    \Comment{zero the last 32-\textit{network\_bits}}
    \State{$\textit{upper\_bound} \gets \text{\textit{ip} OR (\textit{mask} XOR 0xFFFFFFFF)}$}
    \Comment{turn the last 32-\textit{network\_bits} to ones}
    \State{$\textit{addresses} \gets \text{empty list}$}
    \For{$\textit{address} \gets \textit{lower\_bound},\textit{upper\_bound}$}
      \State{append \Call{convert\_to\_dot}{\textit{address}} to \textit{addresses}}
    \EndFor{}
    \Return{\textit{addresses}}
    \EndProcedure{}
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{%
    My algorithm for pretty-printing a dictionary of lists of\gls{port}numbers
    such that ranges are specified as start-end instead of start,start+1,\ldots,end
  }\label{collapse}
  \begin{algorithmic}[1]
  \Procedure{collapse}{}
    \State{$\textit{port\_dictionary} \gets \text{dictionary of lists of\gls{port}numbers}$}
    \State{$\textit{key\_results} \gets \text{empty list}$}
    \Comment{stores the formatted result for each key}
    \For{\textit{key} in \textit{port\_dictionary}}
      \State{$\textit{ports} \gets \text{\textit{port\_dict}[\textit{key}]}$}
      \State{$\textit{result} \gets \textit{key} + \text{``:\{''}$}
      \If{\textit{ports} is empty}
        \State{$\textit{new\_sequence} \gets FALSE$}
        \For{$\textit{index} \gets 1,\text{(length of \textit{ports})}-1$}
          \State{$\textit{port} = \text{\textit{ports}[\textit{index}]}$}
          \If{$\textit{index} = 0$}
            \State{$\textit{result} \gets \textit{result} + \textit{ports}[0]$}
            \Comment{append the first element}
            \If{$\text{\textit{ports}[\textit{index}+1]} = \textit{port} + 1$}
              \State{$\textit{result} \gets \textit{result}+\text{``-''}$}
              \Comment{begin a new sequence}
            \Else{}
              \State{$\textit{result} \gets \textit{result} + \text{``,''}$}
              \Comment{not a sequence}
            \EndIf{}
          \ElsIf{$\textit{port} + 1 \not= \text{\textit{ports}[\textit{index}+1]}$}
          \Comment{break in sequence}
            \State{$\textit{result} \gets \textit{result} + \textit{port} + \text{``,''}$}
            \State{$\textit{new\_sequence} \gets \textit{TRUE}$}
          \ElsIf{$\textit{port}+1 = \text{\textit{ports}[\textit{index}+1]} \And \textit{new\_sequence}$}
            \State{$\textit{result} \gets \textit{result} + \text{``-''}$}
            \State{$\textit{new\_sequence} \gets \textit{FALSE}$}
          \EndIf{}
        \EndFor{}
      \State{$\textit{result} \gets \textit{result} + \text{\textit{ports}[(length of \textit{ports})-1]} + \text{``\}''}$}
      \State{append \textit{result} to \textit{key\_results}}
      \EndIf{}
    \EndFor{}
    \Return{``\{'' + (\textit{key\_results} separated by ``, '') + ``\}''}
  \EndProcedure{}
  \end{algorithmic}
\end{algorithm}

\subsection{Design Data Dictionary}

\textbf{\color{red}{I have no idea what this means.
All I can find is that it relates to database structure???}}

\section{Technical Solution}

\subsection{Program Listing} 
\subsection{Comments (Core)}

\subsection{Overview to direct the examiner to areas of complexity and explain design evidence}

\section{Testing}

\subsection{Test Plan}

\subsection{Test Table / Testing Evidence (Core: lots of screenshots)}

\section{Evaluation}

\subsection{Reflection on final outcome}

\subsection{Evaluation against objectives, end user feedback}

\subsection{Potential improvements}

\section{Appendices}

You may show you program listing here

User feedback and survey data

\clearpage
\printnoidxglossaries{}

\end{document}
